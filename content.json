{"posts":[{"title":"2023杭电多校 赛题总结","text":"前言这篇笔记记录我在 2023 年“钉耙编程”中国大学生算法设计超级联赛（杭电多校）的 10 场比赛中遇到并认为值得记录的赛题题解以及我的思考和收获。 总览 【02-12】Coin 【03-02】King’s Ruins 【04-11】Circuit 【04-12】a-b Problem 【06-02】Pair Sum and Perfect Square 【08-06】Nested String 【08-09】Diagonal Fancy 【08-10】Rikka with Square Numbers 【09-02】Shortest path 笔记 【02-12】Coin题意有 $n(n\\le3000)$ 个人在一起玩游戏。初始时每人拥有 $1$ 枚硬币，接着游戏进行 $m(m\\le 3000)$ 回合。每回合会有两个人 A 和 B 被选中，他们可以有三种选择： A 给 B 一枚硬币 B 给 A 一枚硬币 什么也不做 游戏过程中，限定第 $i$ 个人最多拥有 $a_i$ 枚硬币。求在所有可能的情况中，指定的 $k(k\\le n)$ 个人在游戏结束时最多共拥有多少枚硬币。 做法 通过按照时间阶段拆点，建立网络流模型： 源点向每个人连一条容量为 $1$ 的边 每回合都在选中的二人之间连容量为 $1$ 的边，并将二人的结点扩展出新结点。旧结点到新结点的容量为 $a_i$ 最后将指定的 $k$ 个人的终态结点连向汇点，容量为 $a_i$ 用 Dinic 算法求源点到汇点的最大流即可。 笔记 比较典型的拆点网络流建模。要点是将玩家每回合的状态拆开，然后将游戏回合中的硬币流动抽象为状态之间的流。当网络流中的结点有最大流量限制时，一般都是通过拆点把该限制转换为对边流量的限制。 关于最大流的时间复杂度：在流量极大时，Dinic 算法最坏情况下的时间复杂度为 $O(V^2E)$；而由于跑不满，实际情况中一般 3000 左右的点数和边数就可以使用最大流算法。然而，这题的最大流量较小，情况有所不同：由于每次增广最大流量都会提升，而增广一次的时间复杂度为 $O(E)$，总时间复杂度不会超过 $O(EF)$，其中 $F$ 为最大流量。 【03-02】King’s Ruins题意有 $n(n\\le5\\times10^4)$ 位骑士，分别给定每位骑士在 $5$ 个方面的能力值，以及选择每位骑士可以获得的价值。现在要按从左到右的顺序选择若干位骑士，要求每次选择的骑士在 $5$ 个方面的能力都不能小于上一次选择的骑士。求能够获得的最大价值。 做法 五维偏序问题，若使用 CDQ 分治复杂度为 $O(n\\log^4)$ ，甚至劣于暴力的 $O(n^2)$。 考虑在 $O(n^2)$ 暴力 dp 的基础上应用分块技术。假设每块有 $k$ 个元素，对于每一块，块内元素暴力进行两两间转移需要 $O(k^2)$ ；块内元素与块后方 $O(n)$ 个元素间的转移可以等效为块的某个子集到块后方元素的转移，这需要用 bitset 在 $O(\\frac{nk}{64})$ 预处理出每个块后元素需要转移的子集，并 $O(2^k)$ 预处理出每个子集的最大 dp 值。总共有 $O(\\frac{n}{k})$ 个块，因此总时间复杂度为 $O(\\frac{n}{k}(k^2+\\frac{nk}{64}+2^k)) = O(nk+\\frac{n^2}{64}+\\frac{n\\cdot 2^k}{k})$ 当 $k$ 取 $\\log n$ 时，总时间复杂度为 $O(\\frac{n^2}{\\log n})$，恰好符合要求。 笔记 本题是一个很经典的偏序 dp 问题，但做法却是一个从没见过的神奇分块+bitset优化，记录之。 暴力预处理子集最大值需要 $O(2^k\\cdot k)$ 时间；要想做到 $O(2^k)$ 可以对所有子集进行分治。 似乎有一种类似的算法叫“The Method of Four Russians”/“Four Russians”，思想是将区间每 $O(\\log{n})$ 个元素分为一块，块内暴力计算，块间使用通常算法计算，从而优化通常算法的复杂度。该算法一般用来配合 ST 表优化 RMQ 问题。 【04-11】Circuit题意给定一张 $n(n\\le 500)$ 个点的简单带权有向图，求最小环的长度和个数。 做法 最小环计数问题。为了不重不漏，可以仅在每个环上指向最大编号点的边处考虑该环。 用 Floyd 算法进行最短路计数，同时在枚举中间点 $k$ 时枚举指向 $k$ 的边 $(i,k)$，将以 $k$ 为最大编号点的最小环计入候选表，环的个数即为 $k$ 到 $i$ 的最短路条数。 最后在候选表中选择长度最小的环即可，总时间复杂度为 $O(n^3)$。 笔记 最小环是很经典的图论问题。通常考虑枚举所有边，再根据反向最短路得到包含该边的最小环。有向图或无向图都可以考虑 Floyd 和 Dijkstra： 有向图 Floyd：枚举中间点 $k$ 的同时枚举边 $(i,k)$，看 $k$ 到 $i$ 的最短路。$O(n^3)$。 无向图 Floyd：枚举中间点 $k$ 的同时枚举边 $(i,k)$ 和 $(k,j)$，看 $j$ 到 $i$ 的最短路。$O(n^3)$。 有向图 Dijkstra：枚举所有边 $(i,j)$，求一次 $j$ 到 $i$ 的最短路。$O(m^2\\log{m})$。 无向图 Dijkstra：枚举所有边 $(i,j)$，屏蔽反向边求一次 $j$ 到 $i$ 的最短路。$O(m^2\\log{m})$。 【04-12】a-b Problem题意有 $n(n\\le10^5)$ 块石头，A 和 B 两人轮流进行操作，每次操作从剩余的石头中取一块，A 先手。给定 A 取第 $i$ 块石头的收益 $a_i$ 和 B 取第 $i$ 块石头的收益 $b_i$，求所有决策最优的情况下最终 A 的收益与 B 的收益的差值。 做法 问题可以等效转换为：初始时 $n$ 块石头都在 B 手中，轮到 A 时 A 可以从 B 手中抢走一块石头，而轮到 B 时 B 可以将一块石头藏起来不让 A 拿。若 A 抢走石头 $i$，二人的收益差距将会拉开 $a_i+b_i$。因此 A 和 B 的最优策略都是选择 $a_i+b_i$ 最大的石头。 根据上述结论进行排序模拟即可，时间复杂度为 $O(n\\log{n})$。 笔记 结论很好猜，但是赛时并没有细想怎么证。题解给出的问题转换很巧妙，这种先假设一种极端情况再往另一种极端情况靠近的思想也很常用。 【06-02】Pair Sum and Perfect Square题意给定一个长度为 $n(n\\le10^5)$ 的排列和 $q(q\\le10^5)$ 个询问，每个询问的内容如下： 给定 $L$ 和 $R$，求有多少对 $i,j$ 满足 $L\\le i&lt;j\\le R$ 且 $p_i+p_j$ 是一个完全平方数。 回答所有询问。 做法 $O(n)$ 以内的完全平方数只有 $O(\\sqrt{n})$ 个，所以整个排列中满足条件的元素对只有 $O(n\\sqrt{n})$ 对。 预处理出所有满足条件的点对，并离线所有询问。考虑从右到左在每个后缀上用树状数组维护后缀的前缀的答案数，这样的时间复杂度为 $O((n\\sqrt{n}+q)\\log{n})$，有点难过。 将 $O(\\log{n})$修改+$O(\\log{n})$ 查询的树状数组换成 $O(1)$ 修改+$O(\\sqrt{n})$ 查询的分块，总时间复杂度变为 $O(n\\sqrt{n}+q\\sqrt{n})$，符合时间要求。 笔记 查询满足 $L\\le l&lt;r\\le R$ 的 $(l,r)$ 点对数，类似二维数点问题，非常经典。通常是将点对和询问按照左端点放在一起，从右往左考虑，不断加入左端点为 $i$ 的点对，使得条件 $L=i\\le l$ 自动满足；然后查询前缀 $R$ 中的点对个数，使得 $r\\le R$ 也满足。在点对数与询问数同数量级 $O(q)$ 时，通常用树状数组维护前缀，时间复杂度 $O(q\\log{n})$，比较优秀；然而这题的点对数为 $O(q\\sqrt{q})$ 级别，所以需要引入修改较快、查询较慢的数据结构。分块可以 $O(1)$ 修改、$O(\\sqrt{n})$ 查询，正是一个完美的选择。 其实这题也是一道莫队二次离线模板题，将莫队转移的过程离线下来再通过可差分性预处理即可。 【08-06】Nested String题意给定字符串 $T_1,T_2,S(|T_1|,|T_2|,|S|\\le 10^7)$，定义「T-嵌套串」为在 $T_1$ 任意位置插入 $T_2$ 得到的字符串。求 $S$ 中包含多少个位置不同或本身不同的T-嵌套串。 做法 数据范围为 $10^7$，只能考虑 $O(n)$ 算法。而字符串哈希的时空复杂度常数较大，难以通过。 T-嵌套串的长度固定为 $|T_1|+|T_2|$，因此可以考虑枚举其在 $S$ 中的位置。对于每个位置 $S[l,r]$，判断它是否为T-嵌套串需要知道的是： $S[l,r]$ 与 $T_1$ 的最长公共前缀 $S[l,r]$ 与 $T_1$ 的最长公共后缀 $T_2$ 与 $S[l,r]$ 匹配的位置 其中，1 和 2 等价于 $S$ 的所有后缀/前缀与 $T_1$ 的最长公共前缀/后缀，可以通过扩展 KMP 算法预处理得到；而 3 可以通过 KMP 算法轻松计算。 在预处理出上述信息后，对于每个位置 $S[l,r]$ 就可以算出 $T_2$ 插入后符合要求的位置范围。对该范围利用前缀和进行区间累加，最后再遍历 $T_2$ 在 $S$ 中的匹配位置即可统计出答案。 笔记 本题的要点在于将T-嵌套串分成三部分考虑，并将T-嵌套串前缀和后缀的匹配转换为 LCP 问题。处理模式串与文本串所有后缀的 LCP 是扩展 KMP 算法的典型应用。 【08-09】Diagonal Fancy题意给定一个 $n\\times m(\\sum n\\times m\\le 10^7)$ 的矩阵，求其中有多少个子正方形，满足该子正方形内每个从左上到右下的对角线内部的数字相同，且不同对角线之间数字互不相同。 做法 对于第一个条件，可以通过动态规划来维护：用 $dp(i,j)$ 表示以 $(i,j)$ 为右下角的满足第一个条件的最大正方形边长，有 $dp(i,j)=\\min{dp(i-1,j),dp(i,j-1),dp(i-1,j-1)}+1$。 对于第二个条件，继续考虑上述转移：$dp(i-1,j)$ 保证了靠右上的 $2n-3$ 条对角线互不相同，$dp(i,j-1)$ 保证了靠左下的 $2n-3$ 条对角线互不相同，$dp(i-1,j-1)$ 保证了居中的 $2n-3$ 条对角线互不相同。因此只需要在转移时再检查一下靠右上的两条对角线和靠左下的两条对角线是否互不相同即可。若互不相同，则 $dp(i,j)=\\min{dp(i-1,j),dp(i,j-1),dp(i-1,j-1)}+1$，否则 $dp(i,j)=\\min{dp(i-1,j),dp(i,j-1),dp(i-1,j-1)}$。 总时间复杂度 $O(nm)$。 笔记 找符合条件子正方形常用的一种经典动态规划转移：$dp(i,j)=\\min{dp(i-1,j),dp(i,j-1),dp(i-1,j-1)}+1$。 【08-10】Rikka with Square Numbers题意给定两个整数 $a,b(1\\le a,b\\le 10^9,a\\neq b)$。每次操作可以让 $a$ 加或减一个完全平方数，求最少几次操作才能使 $a$ 变成 $b$。 做法 令 $d=|a-b|$，则相当于将 $b$ 表示为若干完全平方数的和或差。 若 $d$ 为完全平方数，则答案为 $1$。 否则分类讨论： 若 $d$ 为奇数，则 $d=d\\times 1=(\\lceil\\frac{d}{2}\\rceil+\\lfloor\\frac{d}{2}\\rfloor)(\\lceil\\frac{d}{2}\\rceil-\\lfloor\\frac{d}{2}\\rfloor)=\\lceil\\frac{d}{2}\\rceil^2-\\lfloor\\frac{d}{2}\\rfloor^2$，答案为 $2$ 若 $d$ 为 $4$ 的倍数，则 $d=\\frac{d}{2}-(-\\frac{d}{2})=(\\frac{d}{4}+1)^2-(\\frac{d}{4}-1)^2$，答案为 $2$ 若 $d$ 为 $4k+2$，首先至少可以花一步转换为奇数，即答案至多为 $3$，所以只需要判断 $d$ 能否表示为两平方数的和或差。由于 $p^2-q^2=(p+q)(p-q)$，$(p-q)$ 和 $(p+q)$ 的奇偶性一定相同，$p^2-q^2$ 不可能为 $4k+2$，即 $d$ 不可能表示为完全平方数的差。所以只需要枚举比 $d$ 小的所有完全平方数判断 $d$ 是否能表示为完全平方数的和即可。 总时间复杂度 $O(\\sqrt{|a-b|})$。 笔记 与完全平方数相关的两个经典结论： 奇数和 $4$ 的倍数一定能表示成两个完全平方数之差 两个完全平方数之差一定是奇数或 $4$ 的倍数，即 $4k+2$ 不可能表示成两个完全平方数之差 【09-02】Shortest path题意有一张包含 $n(n\\le10^{18})$ 个结点的图，对于每个结点 $i$ 按照如下方式建立有向边： 若 $2i\\le n$，则结点 $i$ 向结点 $2i$ 连边 若 $3i\\le n$，则结点 $i$ 向结点 $3i$ 连边 若 $i+1\\le n$，则结点 $i$ 向结点 $i+1$ 连边 求结点 1 到结点 $n$ 的最短距离。 做法 将问题逆向，相当于通过除以 $2$、除以 $3$、减 $1$ 三种操作将一个初始为 $n$ 的数变为 $1$。 先减两次再除以 $2$ 或先减三次再除以 $3$ 都是非最优的，因此每次除以 $2$ 前最多减 $1$ 次，每次除以 $3$ 前最多减 $2$ 次。 从 $n$ 出发记忆化搜索，每次除以 $2$/除以 $3$ 操作一定在下方最近的 $2$ 的倍数/$3$ 的倍数处进行。搜到的点都可以表示为 $\\lfloor \\frac{n}{2^a3^b}\\rfloor$，总共有 $O(\\log^2n)$ 个。 笔记 典中典套路。将减 $1$ 操作作为基本操作，填充在特殊操作（除以 $2$/除以 $3$）之间，搜索时直接跳过，不需要记录每次减 $1$ 操作的结果，这样才能保证较低的时间复杂度。 元素个数较少时可以用 unordered_map 优化复杂度。","link":"/post/2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"title":"2023牛客暑期多校训练营 赛题总结","text":"前言这篇笔记记录我在 2023 年牛客暑期多校训练营的 10 场比赛中遇到并认为值得记录的赛题题解以及我的思考和收获。 总览 【01C】Carrot Trees 【02F】Link with Chess Game 【02G】Link with Centrally Symmetric Strings 【03B】Auspiciousness 【04H】Merge the squares! 【04L】We are the Lights 【05C】Cheeeeeen the Cute Cat 【05E】Red and Blue and Green 【05I】The Yakumo Family 【06A】Tree 【06H】traffic 【06J】Even 【08J】Permutation and Primes 【09G】Non-Puzzle: Game 【09I】Non-Puzzle: Segment Pair 笔记 【01C】Carrot Trees题意给定长度为 $n(n\\le 10^6)$ 的实数序列 $a$ 和一个整数 $k$，初始时全为 $0$，对其进行 $m(m\\le 2\\times 10^5)$ 次操作： 将区间 $[l,r]$ 中所有元素加上 $\\dfrac{x}{k}$ 将区间 $[l,r]$ 中 $a_i\\ge 1$ 的元素减去 $1$ 求经过所有操作后所有元素共被减过多少次。 做法 将所有数值乘 $k$，实数问题转化为整数问题。 无视 $a_i\\ge 1$ 的限制，每次操作 2 都将区间所有数减 $k$，这样最后 $a_i$ 的历史最小值与 $k$ 的差距就反映了它被多减去 $k$ 的次数 $c_i$：$c_i=\\lceil \\dfrac{-\\min a_i}{k} \\rceil$，问题转化为历史最值问题。 这里的历史最值问题可以在线或离线处理。离线方法：用线段树维护 $a_1$ 每一次操作后的值，这样整个大区间的最值就是 $a_1$ 的历史最值。然后对操作序列的后缀施加以 $2$ 为左端点的操作或以 $1$ 为右端点的操作，就可以将线段树维护的内容转换为 $a_2$ 每次操作后的值，以此类推，就可以求出每个 $a_i$ 的历史最值。 整个过程的时间复杂度为 $O((m+n)\\log m)$。 笔记 这题的核心在于“多减的量由历史最小值反映”这一点。可以这样理解：将 $a_i$ 的所有历史值看作一个序列，我们将使得 $a_i$ 跌下 $0$ 的 $k$ 归还，相当于是对一个后缀进行区间加，而显然最后一次进行后缀加的位置一定是序列的最小值点。 这个离线求历史最值的方法很巧妙。整个问题的模型实际上是一个三维空间，三个维度分别为数组下标、操作序号、元素数值。传统线段树一般在数组下标上维护元素数值，并随着操作序号变化；而这里转换了一下方向，在操作序号上维护元素数值，并随着数组下标变化。 【02F】Link with Chess Game题意有长宽高为 $n(n\\le 10^5)$ 的三维空间（$1\\le x,y,z\\le n$），初始有一个点在 $(x_0,y_0,z_0)$。两人轮流将点沿坐标轴方向移动一格，不能移动到已到达过的点或空间外，不能移动者输。求先手必胜还是后手必胜。 做法 因为对于两个相邻的点，$x\\oplus y\\oplus z$ 的奇偶性一定不同，因此所有点可以按照 $x\\oplus y\\oplus z$ 被划分为两部，问题转换为二分图博弈问题。 当 $n$ 为偶数时，所有最大匹配都包含所有点，因此先手必胜。 当 $n$ 为奇数时，二分图奇数部点数更多，说明一定有奇数部点不在最大匹配上，尝试构造发现任何奇数部点都有可能不在最大匹配上，因此 $x_0\\oplus y_0\\oplus z_0$ 为奇数时后手胜，反之先手胜。 笔记 第一次了解二分图博弈这个模型，感觉证明很妙。 模型：在一个二分图上，两人轮流沿着无向边推动一个棋子，且不能到达曾经到达过的点，不能推者输。 结论：若起始点一定在二分图的所有最大匹配上则先手必胜，反之后手必胜。 证明：I. 所有最大匹配都包含起始点时，先手每轮都沿着匹配的边走，后手只要能移动就一定会到达下一个匹配点，因此先手必胜。因为若后手到达非匹配点，将棋子移动路径整体向后偏移一次，可以得到一个不包含起始点的最大匹配，与条件矛盾。II. 存在一个最大匹配不包含起始点时，先手第一次移动一定会到达这个最大匹配的一个匹配点，因此两级反转，后手必胜。因为若先手第一次移动可以到达一个非匹配点，则该点和起点可以加入匹配，得到一个更大的匹配，与条件矛盾。 解法：通常做法是用 Dinic 算法跑两次最大流。建图时先不建起点的邻接边，跑第一次；然后加上起点的邻接边，跑第二次，看第二次的最大流是不是 $0$。若是 $0$ 则说明存在不包含起点的最大匹配，反之则说明起点对于最大匹配是必不可少的。模板题：https://codeforces.com/gym/102832/problem/H 。 【02G】Link with Centrally Symmetric Strings题意给定长度为 $n(n\\le10^6)$ 的字符串。求它是否能拆分成若干个中心对称子串。 中心对称的定义：o / s / x / z 自身中心对称；b·q / d·p / u·n / o·o / s·s / x·x / z·z 相对中心对称。 做法 “中心对称串”可以看作是稍微修改了回文串的定义，其性质依然适用 Manacher 的推导，因此可以用 Manacher 算法预处理出每个位置的最长中心对称半径。 考虑维护符合要求的前缀。假设前缀 $pre_i$ 符合要求，以 $i+1$ 为起点的所有中心对称子串 $s_1,s_2,…,s_k(|s_1|&lt;|s_2|&lt;…&lt;|s_k|)$ 都可以用于转移，但这里的 $s_2,s_3,…,s_k$ 一定都可以再拆分为若干中心对称子串，所以选择最短的回文子串 $s_1$ 转移一定是最优的。 根据上述结论，只要从左到右枚举每个位置作为转移子串的对称中心，选最短的半径进行转移，一定就能找出所有符合要求的前缀。 整个过程的时间复杂度为 $O(n)$ 。 笔记 这题的关键在于“同一起点的较长对称串可再分”这一结论。思考了一下，这个结论可以拓展到回文串，并且等价于——中心对称串/回文串都有“最小拆分唯一”的性质：将它们拆分为若干中心对称/回文串直到不可再分，得到的结果是唯一的（感觉是常见套路，证明思路也很常见）。因为前缀 $pre_i$ 能转移到的所有前缀，$pre_i+s_1$ 也都能转移到。下面证明 $s_i(i\\ge 2)$ 都可再分且再分后的第一块为 $s_1$： 首先反证法证明 $|s_1|\\le \\lfloor\\dfrac{|s_i|}{2}\\rfloor$：假如 $|s_1|&gt;\\lfloor\\dfrac{|s_i|}{2}\\rfloor$，可以设 $s_1=A+B$，$s_i=A+B+A’$，由 $s_i$ 对称性，$B$ 是对称的；又由 $s_1$ 对称性，$s_1$ 一定有一个更短的对称前缀 $B’$，与条件不符，证毕。 然后就可以假设 $s_i=s_1+S+s_1’$。由 $s_i$ 和 $s_1$ 都是对称的，可得 $s_1$、$S$、$s_1’$ 都是对称的，原结论证毕。 【03B】Auspiciousness题意$2n(n\\le 300)$ 张牌面数字分别为 $1,2,…,2n$ 的牌叠放成牌堆，完成以下流程： 从牌堆顶取走一张牌 若牌堆为空则结束流程，否则猜测牌堆顶数字是否大于上一张取走的牌，并从牌堆顶取走一张牌 若猜测正确则回到上一步继续，否则结束流程 依照“上一张牌不超过 $n$ 则猜测牌堆顶大于上一张牌，否则猜测小于”的策略猜测。求对于所有可能的 $(2n)!$ 种牌堆叠放顺序，总共能取走的牌的数量之和。 做法 记 $[1,n]$ 为小数，$[n+1,2n]$ 为大数。考虑摸到牌的序列，一定是小数上升序列和大数下降序列的交替。 设计 $dp(i,j,k)$ 表示已经填了 $i$ 个小数和 $j$ 个大数，最后一段是小数/大数的方案数，进行动态规划。动态规划前需要预处理出组合数 $C_i^j$ 的值以便于 $O(1)$ 转移。 对于每个位置 $i$，计算可以拿第 $i$ 张牌的方案数，然后求和。答案为 $\\sum_{i=1}^{n}\\sum_{x=0}^{i-1}\\sum_{k=0}^{1}dp(x,i-1-x,k)\\cdot(2n-i+1)!$。 整个过程的时间复杂度为 $O(n^2)$。 笔记 这题的关键在于如何划分状态以及如何利用状态的值计数。通常动态规划时的想法是直接用 dp 值来表示能拿走的牌数，然后对所有 dp 值求和得到答案。但这样必须考虑每一种方案下，下一次猜测失败的情况数，且不方便进行状态转移；并且这样其实存在信息的冗余，因为每一个状态拿了几张牌的信息已经包含在前两维 $i$ 和 $j$ 里了。题解不直接用 dp 值存答案，而是用它来存关键的中间量，很巧妙。 【04H】Merge the squares!题意有一个大小为 $n\\times n(n\\le 1000)$ 的正方形，由 $n^2$ 个 $1\\times 1$ 的小正方形组成。每次操作可以选择 $x(2\\le x\\le 50)$ 个完整的正方形并将它们原地组合成一个完整大正方形，求一种由 $n^2$ 个小正方形构造出完整 $n\\times n$ 大正方形的方案。 做法 逆向思维，将组合过程逆向为拆解过程，问题转化为求将 $n\\times n$ 大正方形拆解为 $1\\times 1$ 小正方形的方案。 预处理出将 $i\\times i$ 的大正方形左上角拆下一个 $j\\times j$ 的小正方形，右下角拆下一个 $(i-j)\\times (i-j)$ 的小正方形后得到的两个矩形最少可以拆解为多少个正方形，对于每个 $i$，找到一个结果不超过 48 的 $j$ 作为遇到 $i\\times i$ 正方形时的拆解预案。 利用预处理出的预案递归构造答案。 笔记 这题没做出来该反思。传统构造题的构造方法一般都比较固定和巧妙（虽然这题也可以固定），但这题预处理并自动选择构造方案，比较出乎意料。对于大正方形直接拆成两个正方形和两个矩形然后直接辗转相减就一定有解也是没想到的一个点，或许应该多打表尝试一下的。 这题还有一种神奇做法是每次拆解大正方形都固定选在黄金分割点，这样得到的矩形长宽是黄金比例的，辗转相减得到的正方形会比较少。对斐波那契和黄金分割这些了解不多，不太懂深层的原理。 【04L】We are the Lights题意有一个 $n\\times m(n,m\\le 10^6)$ 的网格，每一格上有一个灯，初始时都是灭的。进行四种操作： 打开所有第 $i$ 行的灯 关闭所有第 $i$ 行的灯 打开所有第 $i$ 列的灯 关闭所有第 $i$ 列的灯 求经过 $q(q\\le 10^6)$ 次操作后亮着的灯的数量。 做法 观察到重要性质：后继操作会覆盖前驱操作，灯的亮灭取决于最后一次对它进行的操作。 逆向思维，逆着操作顺序从后往前考虑，同时记录每一行每一列是否操作过以及操作的类型。对于每一行，只需要考虑对该行的第一次操作：在第一次操作该行时，根据已经操作过的列情况计算这一行灯的贡献，最后将所有行贡献求和即得答案。 笔记 签到题，比较简单，但是感觉比较妙，值得品味。值得一提的是做法里行和列的地位并不对等，要么是以列为条件计算行贡献，要么是以行为条件计算列贡献。 还有一种类似的问题是每次翻转一行或一列。那样的话只需要记录每一行和每一列的翻转状态（0 或 1）了，并且每一行的情形最多就只有两种，因为列操作对每一行都是平等的，行与行之间的差别只与行操作有关（“行”、“列”互换亦然）。举例：https://ac.nowcoder.com/acm/contest/57357/D 。 再补充一个行列操作的问题，是每次交换任意两行或任意两列的：https://ac.nowcoder.com/acm/contest/57362/K 。 【05C】Cheeeeeen the Cute Cat题意给定一张 $2n(n\\le3000)$ 个点，$\\dfrac{n(n-1)}{2}$ 条边的二分图，保证： $i$ 和 $i+1$ 间没有连边 $i$ 和 $j+n$ 以及 $i+n$ 和 $j$ 之间不同时有连边 求该二分图的最大匹配。 做法 题目给的限定条件显然是为了将问题转换到一张竞赛图上：$i$ 与 $j+n$ 的无向边对应竞赛图中 $i$ 到 $j$ 的有向边。现在要求在保证每个点入度出度不超过 $1$ 的情况下最多选多少条边。 竞赛图一定存在一条哈密顿通路，所以答案至少为 $n-1$。 竞赛图中每个强连通分量一定存在一条哈密顿回路，所以当且仅当所有强连通分量大小都大于等于 3 时答案为 $n$。 求强连通分量时间复杂度 $O(n^2)$。 笔记 对竞赛图不太熟悉。这里记录一下竞赛图的相关知识。 竞赛图若存在环，则一定存在三元环 竞赛图一定含有哈密顿通路 构造方法：每次加入一个点 $x$，设加入前的哈密顿通路起点终点分别为 $S,T$，若存在有向边 $(x,S)$ 或 $(T,x)$，则直接将 $x$ 从端点处加入通路；否则 $S,T$ 与 $x$ 间的边一定是从 $(S,x)$、$(x,T)$，这样的话通路中一定有两个相邻的点 $u,v$ 满足存在 $(u,x),(x,v)$，此时将 $x$ 插入 $u,v$ 间即可。 竞赛图中每个强连通分量一定存在一条哈密顿回路（构造方法类似上述增量构造） 兰道定理：定义比分序列 $s$ 为所有点的出度构成的序列排序而成的序列。则比分序列合法当且仅当： $\\forall k \\in [1,n]$, $\\sum_{i=1}^{k}s_i\\ge C_k^2$，且 $\\sum_{i=1}^{n}s_i=C_n^2$。 把出度换成入度也成立。 理解：竞赛图缩点后形成一条链，其中离链头较近的 SCC 中点的出度一定严格大于离链头较远的 SCC 中点的出度，因此比分序列就是由从链尾起的每个 SCC 对应的连续区间连接而成的。当 $\\sum_{i=1}^{k}s_i\\ge C_k^2$ 取等时，说明前 $k$ 个点没有连向其余点的边，即前 $k$ 个点构成链尾若干个强连通分量。所以，兰道定理除了能判断比分序列合法性，还可以求强连通分量：$\\sum_{i=1}^{k}s_i\\ge C_k^2$ 取等处就是强连通分量的临界处。 参考博客：https://www.cnblogs.com/xzzduang/p/17205687.html 【05E】Red and Blue and Green题意给定 $m(m\\le 10^3)$ 个约束，每个约束的形式为：区间 $[l,r]$ 的逆序对奇偶性为 $w$。求一个长度为 $n(n\\le 10^3)$ 的排列，使其满足所有约束，或断定不存在这样的排列。 做法 以区间的直接包含关系连接所有约束后，所有约束之间将会构成一个树形结构。 改变区间奇偶性只需要交换任意两个元素一次。 将有根树构造出来，对于一个初始为顺序的排列，在树上 dfs 的同时自下而上修改排列。针对一个约束节点进行修改时，首先对它所有子节点的逆序对奇偶性求和，判断它是否需要继续修改；要想在当前节点的区间中交换两个数同时不影响子孙节点的结果，只要保证交换的两个数不在同一个子节点区间中，并且在子节点区间中的数原本是最大（小）值，交换后还是最大（小）值。由于子节点区间不等于当前节点区间，且当前节点和子节点的区间 $[l,r]$ 一定都是 $[l,r]$ 的一个排列，一定能找到一对满足条件的数进行交换。假设当前区间为 $[L,R]$，一个子节点区间为 $[l,r]$，则选取 $[L,R]$ 中位于 $[l,r]$ 左侧的数与 $[l,r]$ 中最小值交换或选取 $[L,R]$ 中位于 $[l,r]$ 右侧的数与 $[l,r]$ 中的最大值交换即可。 笔记 这题的关键有两点：区间之间是树形关系且可以自下而上修改、如何保证当前节点的修改不扰乱其他节点。自下而上修改可以保证当前节点的区间 $[l,r]$ 一定是 $[l,r]$ 的一个排列，这又使得 $[l,r]$ 左侧的数一定比它们都小，右侧的数一定比它们都大，以至于一定能找到可交换的数。 【05I】The Yakumo Family题意给定一个长度为 $n(n\\le 2\\times10^5)$ 的序列 $a$，求： $\\sum_{1\\le l_1\\le r_1&lt;l_2\\le r_2&lt;l_3\\le r_3\\le n} XOR(l_1,r_1)\\cdot XOR(l_2,r_2)\\cdot XOR(l_3,r_3)$ 其中 $XOR(l,r)$ 表示 $a_l\\oplus a_{l+1}\\oplus\\cdots\\oplus a_r$。 做法 区间异或和可以通过端点的前缀异或得出，因此我们预处理出所有前缀异或和 先求解 $\\sum_{1\\le l_1\\le r_1\\le i} XOR(l_1,r_1)=\\sum_{b=0}^{30}\\sum_{1\\le l_1\\le r_1\\le i}[a_{l_1,b}\\neq a_{r_1,b}]\\cdot 2^b$：拆位后相当于计算前缀异或和上每个位置前面有多少位置在这一位上与它相反。记算出的结果为 $sum_i=\\sum_{1\\le l_1\\le r_1\\le i} XOR(l_1,r_1)$。 再求解 $\\sum_{1\\le l_1\\le r_1&lt;l_2\\le r_2\\le i} XOR(l_1,r_1)\\cdot XOR(l_2,r_2)=\\sum_{b=0}^{30}\\sum_{1\\le l_2\\le r_2\\le i}sum_{l_2-1}\\cdot [a_{l_2,b}\\neq a_{r_2,b}]\\cdot 2^b$：与上一步类似，但将“前面每个相反项 $i$ 都贡献 $1$”的前缀和改为“前面每个相反项 $i$ 都贡献 $sum_i$” 的前缀和，算出结果 $sum_i’=\\sum_{1\\le l_1\\le r_1&lt;l_2\\le r_2\\le i} XOR(l_1,r_1)\\cdot XOR(l_2,r_2)$。 依照上述规律再套一层，将前缀和改为“前面每个相反项 $i$ 都贡献 $sum_i’$”，算出最终结果 $sum_n’’$。 笔记 这题的做法实际上是嵌套了三层配合拆位利用前缀和加速计算的过程。要求 $n$ 项乘积的和，就要对 $n-1$ 项乘积的前缀和进行求和。 这种对一个好几项相乘的式子求和，并且式子中带位运算的问题很常见，再举一例：https://ac.nowcoder.com/acm/contest/57361/K 。这类问题经常需要拆位+前缀和的思想。拆位可以将位运算转换为 0 和 1 之间的简单逻辑，同时时间复杂度只提升 32 倍；而前缀和可以将复杂的枚举求和过程压缩为多次 $O(n)$ 求和。这类问题的关键就在于如何设计前缀和以及如何利用前缀和计算答案，比较容易晕，可以先把式子化出来再想。 【06A】Tree题意给定一棵 $n(n\\le3000)$ 个点的树，包括每个点的颜色（黑或白），同时给出反转每个节点颜色的代价。定义一棵树的收益为所有黑白点对间路径边权最大值的和。求 $收益-总代价$ 的最大值。 做法 路径最大边权问题，考虑构造 Kruskal 重构树，两节点的 LCA 即路径边权最大值。 在 Kruskal 重构树上 dp：定义 $dp(i,j)$ 表示在节点 $i$ 的子树中有 $j$ 个黑点时的最大答案，用类似于树上背包问题的方法进行转移。最终 $\\max_{i=0}^ndp(root, i)$ 即为答案。 整个过程的时间复杂度为 $O(n^2)$。 笔记 这题的关键在于判断出树上 dp 的时间复杂度为 $O(n^2)$ 而不是 $O(n^3)$。这实际上是一个常见模型和结论：在二叉树上 dp 时，计算一个节点的 dp 值需要枚举左子树大小再嵌套枚举右子树大小，这个过程相当于枚举子树中 LCA 为当前节点的点对。而整棵树的所有点对只有 $O(n^2)$ 对，因此时间复杂度只有 $O(n^2)$。 【06H】traffic题意给定一个 $n(n\\le 10^5)$ 个点，$n+1$ 条边的无向连通图，图上每条边的边权都是 $t$ 的一次函数，并且一次函数的斜率和截距都给定。分别求 $t=0,1,2,…,T$ 时图的最小生成树边权和。 做法 图的边数为 $n+1$，因此得到最小生成树只需要删除图上两条边，这两条边一定在环上，分两种情况： 两个环没有公共边。此时只要在两个环上分别选一条最大的边删除 两个环有公共边，即存在两个点之间有三条链路，此时需要在这三条链路中选择两条链路，分别删除一条边 进行 dfs 找到两个环或三条链路，然后用李超线段树维护边权函数的最值即可。 笔记 这题的难点在于如何实现找环或找链路的代码，剩下的就是套个李超线段树模板。出题人提供了一个很好的方法：在 dfs 时会遇到两次返祖边，分别对应一个环，对第一个环所有边的标记加 $x$，对第二个环所有边的标记加 $y$。最终若为两个环，则两个环上的边权分别为 $x,y$；若为三条链路，则三条链路上的边权分别为 $x,y,x+y$。我觉得这个方法非常实用，可以举一反三。 我对图论的常见方法太不熟悉了，这里列举一些最近用到的： 无向图找环：dfs，若某边到达访问过的点，则一定是返祖边，对应一个环。维护 dfs 栈，将栈中从当前点到祖先点的所有点打上环标记即可。 有向图找环：Tarjan 算法，dfs 找强连通分量，强连通分量中至少有一个环。 有向图两点间路径/一点所在环：dfs 的同时维护当前路径，遇到目标时直接返回。bfs 因为不能维护路径信息所以不行。 有向图找两个点集间的任一条路径：bfs 找到一个起点 $s$ 和一个终点 $t$，再用 dfs 找 $s$ 到 $t$ 的路径。 【06J】Even题意给定一个长度为 $n(n\\le10^4)$ 的数组 $a$ 以及 $q(q\\le10^5)$ 个独立的询问，每个询问给出 $l,r,k$，假设进行 $k$ 次以下操作： 若数组在区间 $[l,r]$ 中有正偶数，则将 $[l,r]$ 中最大且最左的正偶数减半；否则，将 $[l,r]$ 中最大且最左的数减半。 对每个询问，分别求操作后 $[l,r]$ 中的最大值 $\\max_{i=l}^r a_i$。 做法 观察性质可以发现，整个询问分为两个阶段： 将所有偶数末尾的 $0$ 抹去，直到只剩奇数 每次选出一个最大的奇数右移一位，然后不断抹去末尾所有的 $0$ 同时还可以发现，对每个数的操作最多进行 $\\log$ 次，因此总操作数不超过 $n\\log$ 次。 对于第一阶段，操作 $k$ 次后的最大值等于第 $k+1$ 次操作的对象或最大的奇数。将对区间进行的所有操作的操作数列出来，一定是单调递减的。因此问题转换为求区间操作数集的第 $k+1$ 大。 对于第二阶段，操作 $k$ 次后的最大值等于第 $k+1$ 次操作的对象或第 $k$ 次操作对象变为奇数后的下一个操作对象。将对区间进行的所有操作的操作数列出来，不一定单调递减，但我们可以将一个奇数产生的一系列后续偶数用该奇数替换，替换后一定是单调递减的。因此问题又转换为求区间操作数集的第 $k+1$ 大。 求区间第 $k$ 大用主席树实现，但除主席树模板之外还有一些细节要处理。 操作序列长 $O(n\\log)$，每次插入可持久化线段树 $O(\\log)$，每次询问求区间第 $k$ 大 $O(\\log)$。整个过程的时间复杂度为 $O(n\\log^2+q\\log)$。 笔记 这题的关键在于理清楚操作的本质，然后注意到偶数操作数的单调性以及奇数操作数潜藏的单调性，将问题转换为区间第 $k$ 大问题。确实是很典型也很妙的主席树应用，值得记录。 【08J】Permutation and Primes题意构造一个长度为 $n(n\\le 10^5)$ 的排列，满足对于所有 $1\\le i&lt;n$，要么 $P_i+P_{i+1}$ 是奇质数，要么 $|P_i-P_{i+1}|$ 是奇质数。 做法 方法很多，这里举一例。 将 $[1,n]$ 每 $8$ 个连续的数分一组，按照”$a_1,a_6,a_3,a_8,a_5,a_2,a_7,a_4$” 的顺序循环放置。 此时还剩下 $n%8$ 个数，不妨令它们为 $[1,n%8]$，并放置在排列开头。对每一种情况进行特判，单独构造： [1] [1, 2] [1, 2, 3] [1, 4, 3, 2] [1, 4, 3, 2, 5] [1, 4, 3, 2, 5, 6] [1, 4, 7, 2, 3, 6, 5] 笔记 这题比较容易想到是利用固定长度的循环来构造，并且用到的奇质数不会很多。但可以思考的方向太多了，一开始还是容易没有头绪。找到某一个较小整数（这题的 3/5/8 等）然后利用其性质进行构造的思路比较常见，值得学习。这里举一道由这题联想到的另一道构造题，也是利用某个较小整数的性质：https://ac.nowcoder.com/acm/contest/62977/F 。 【09G】Non-Puzzle: Game题意初始时黑板上写着 $n(n\\le 10^6)$ 个数 $a_i(0\\le a_i&lt;2^{30})$，给定一个数 $k(0\\le k&lt;2^{30})$，两个人轮流进行下述操作： 在黑板上选择两次数（两次选择的可以是同一个数），记选中的数分别为 $x,y$，然后将 $x\\oplus y$ 写到黑板上。 规定第一次写出 $k$ 的人获胜；若进行无限回合都写不出 $k$ 则平局。求先手必胜还是后手必胜还是平局。 做法 分情况讨论：如果初始时黑板上就有两个数的异或为 $k$，则先手必胜；否则，如果无论先手怎么选择，黑板上都会有两个数的异或为 $k$，则后手必胜；如果上述两种情况都不成立，说明两人都不可能一步制胜，这意味着两人若进行有效操作改变局面，就有可能被对手抢占先机。所以此时两人都会摆烂，进行与上一次相同的无效操作，达成平局。 对于第一种情况，只要用 set/unordered_set 判断 $a_i\\oplus k$ 是否存在即可。 对于第二种情况，先手操作后得到 $a_i\\oplus a_j$，后手利用该数一定能获胜，相当于：对于所有 $i,j$，都存在 $x$ 满足 $a_i\\oplus a_j\\oplus a_x=k$。等价变换后得：对于所有 $i,j$，都存在 $x$ 满足 $(a_i\\oplus k)\\oplus (a_j\\oplus k)=(a_x\\oplus k)$。设 $a_i’=a_i\\oplus k$，则条件又转换为：$a_i’$ 构成的集合对于异或运算封闭。这意味着所有 $a_i’$ 张成的向量空间就是 $a_i’$ 构成的集合本身。因此只需要计算 $a_i’$ 的线性基维数 $b$，然后判断 $a_i’$ 构成的集合大小是否为 $2^b$ 即可（因为线性基本来就是由该集合算出来的，所以不需要一一检查集合中的数是否都在线性基确定的空间中）。 笔记 这题的关键在于如何判断后手是否必胜。我一开始推出的条件是 ${a_i\\oplus a_j|i,j\\in[1,n]}\\subseteq {a_i\\oplus k|i\\in[1,n]}$，然后错误地得到了 $\\forall j\\in[1,n]$, $a_j=k$，贡献一发罚时。但实际上这里的两个 $i$ 并不是同一个 $i$。做法里将 $a_i\\oplus a_j\\oplus a_x=k$ 变化为 $(a_i\\oplus k)\\oplus (a_j\\oplus k)=(a_x\\oplus k)$，然后转换视角到 $a_i’=a_i\\oplus k$ 的操作很关键，也很妙，但是感觉不容易想到，可能还需要多练。 【09I】Non-Puzzle: Segment Pair题意给定 $n(n\\le5\\times 10^5)$ 组区间，每组包含两个区间 $[l,r],[l’,r’](1\\le l,r,l’,r’\\le 5\\times 10^5)$。现在要从每组中选择一个区间，满足得到的 $n$ 个区间的交集不为空。求可行的选择方案数。 做法 枚举交集的左端点 $i$，则相应的方案需要满足包含 $i$ 而不包含 $i-1$。因此对于交集左端点为 $i$ 的情况，可以先分别计算包含 $i$ 的方案数和同时包含 $i,i-1$ 的方案数，再相减得到合法的方案数。 在进行上述过程之前，需要先进行预处理：对每组区间，用差分的方法对数轴上的段打统计标记，分别标记两个区间都包含的段和只有一个区间包含的段，最终统计出数轴上每个位置有多少组两区间都覆盖、有多少组只有一个区间覆盖。然后就可以开始根据这些信息计算每个左端点的方案数了。 笔记 我在赛场上的做法本质上和题解一样，也是根据交集的左端点来划分所有方案，但利用的条件是“方案中至少有一个区间以 $i$ 为左端点，且所有区间都包含 $i$”，并且不是枚举所有位置为左端点，而是直接枚举可能为左端点的位置（所有组中区间的左端点），搞复杂了。原因或许是没有想清楚交集以 $i$ 为左端点的本质原因——不是“有区间以 $i$ 为左端点”，而是“有区间不包含 $i-1$”。我的想法是“用一个以 $i$ 为左端点的区间来保证 $i$ 是交集左端点”，而不是“减去包含 $i-1$ 的方案数来保证 $i$ 是交集左端点”。","link":"/post/2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"},{"title":"2024.4 刷题笔记","text":"CF1870E题意对长度为 $n(n\\le 5000)$ 的数组 $a(a_i\\in [0,n])$，选择若干不重合的子段分别计算 MEX 再异或起来，求该异或值的最大值。 做法 很容易想到朴素的 dp 做法：令 $dp(i,j)$ 表示考虑前 $i$ 个元素能否得到异或值 $j$，对于每个状态从前缀所有元素转移，时间复杂度 $O(n^3)$ 考虑到 MEX 相同的段中只有极小子段用于转移有意义，可以发现极小子段只有 $O(n)$ 个，于是只要预处理出有意义的极小子段再 $O(n^2)$ 转移即可 CF1884D题意给定长度为 $n(n\\le 10^6)$ 的数组 $a(1\\le a_i\\le n)$，求不存在 $x\\in a$ 使得 $x|a_i$ 且 $x|a_j$ 且 $i&lt;j$ 的 $(i,j)$ 对数。 做法 计算 $gcd(a_i,a_j)=x$ 的 $(i,j)$ 对数 $dp(x)$ 对于所有没有因子在 $a$ 中的数 u，计算 $\\sum_u dp(u)$，即为答案 CF1861E题意定义序列 $a$ 最多包含 $cost_a$ 个不重叠的子段，满足每个子段都是 $[1,k]$ 的排列。对于所有长度为 $n(n\\le 4000)$ 且仅包含 $[1,k](k\\le 4000)$ 的序列，求它们 $cost$ 的和。 做法 计算 cost 的策略是从左到右扫描长度为 $k$ 的窗口，将每次最先出现的 k 排列计入答案 考虑统计所有序列中每个位置上被计入答案的 k 排列个数。以 $i$ 位置结尾的 k 排列被计入答案的前提是以 $[i-k+1,i-1]$ 结尾的子段都没有被计入答案 定义 $dp_i$ 表示在 i 位置被计入答案的 k 排列个数，则按照上述策略，$dp_i=k^{i-k}\\cdot k!-\\sum_{j=i-k+1}^{i-1} dp_j\\cdot (i-j)!$，即所有 i 位置为 k 排列的序列个数减去以 $[i-k+1,i-1]$ 结尾的子段被计入答案的序列个数 答案为 $\\sum_{i=k}^{n} dp_i\\cdot k^{n-i}$ CF895C题意给定长度为 $n(n\\le 10^5)$ 的序列 $a(1\\le a_i\\le 70)$，求序列有多少个非空子集满足所有元素的积是一个完全平方数。 做法 乘积为完全平方数等价于所有质因子出现的次数都为偶数，而 $70$ 以内的质数非常少，可以进行状态压缩，转换为线性基经典问题，即求一组向量和为 0 的线性组合个数 $n$ 个向量的集合 $s$ 中和为 0 的线性组合个数为 $2^{n-rank(s)}$，其中包含一个空集，需要去掉 CF1896D题意给定一个长度为 $n(n\\le 10^5)$ 只包含 $1$ 和 $2$ 的数组以及 $q(q\\le 10^5)$ 个询问，每个询问要么对数组单点修改，要么求是否存在和为 $s$ 的子数组。 做法 观察到：对于一个子数组，若其左边或右边为 $2$ 则可以删去使和减少 $2$，否则可以同时去掉两边的 $1$ 同样使和减少 $2$。因此只要和为 $sum$ 的子数组存在，和为 $sum-2,sum-4,…$ 的子数组就一定也存在 只需要找到与询问的 $sum$ 奇偶性相同且和最大的子数组即可判断。这可以通过维护所有为 $1$ 的位置来完成 CF1913D题意给定所有元素互不相同的、长度为 $n(n\\le 3\\cdot 10^5)$ 的序列 $p$ 和一种操作： 选择 $p$ 中一个子段，删除除了最小元素以外的所有元素 求进行任意次操作可以得到的所有结果序列的种类数。 做法 等价于求合法子序列个数，因此考虑动态规划：用 $dp_i$ 表示对前缀 $i$ 进行操作能得到且不删除第 $i$ 个元素的子序列个数 对于 $dp_i$ 考虑从左边哪些位置转移合法： 若 $p_i$ 左边没有更小的数，则 $[0,i)$ 都合法 否则，记 $l(i)$ 为 $p_i$ 左边第一个比 $p_i$ 小的元素的位置，合法的转移位置有 $[l(i),i)$ 以及 $l(l(i)),l(l(l(i))),…$ 需要注意：情况 1 中位置 $0$ 合法，情况 2 中位置 $0$ 不合法 在从左到右扫描的过程中，记录 $dp_i$ 的前缀和以及通过 $l$ 关系形成的链上的 dp 值的前缀和，就可以做到 $O(1)$ 转移 最终找到所有满足“比自己右边所有元素都大”的 $p_i$ 的位置 $i$，对这些位置的 dp 值求和即为答案 CF1922D题意给定一排 $n(n\\le 3\\cdot 10^5)$ 个怪物，每个怪物的伤害和一次性最多能接受的伤害分别为 $a_i$ 和 $d_i$。每个回合，所有怪物会先对左边和右边第一个存活的怪物造成伤害，然后受到他们的伤害。问前 $n$ 个回合中分别有多少个怪物死亡。 做法 在某一回合中，若某怪物自己没有死亡，且相邻的两个怪物也没有死亡，则在下一回合中不需要考虑它。换句话说，每个回合只需要检查上个回合死亡的怪物的相邻怪物即可 整个过程中最多有 $n$ 个怪物死亡，每个怪物死亡时，下回合需要考虑其相邻的两个怪物；同时初始时需要考虑所有 $n$ 个怪物。因此总共需要考虑的次数为 $O(3n)$ 用 set 维护当前活着的怪物可以方便地找到每个怪物的相邻怪物 CF1942D题意有一个包含 $n(n\\le 10^3)$ 格的条带，可以任选格子涂上颜色。对于 $2^n$ 种选择中的一种，其对应的得分是 $a_{x_1,x_2}+a_{x_3,x_4}+…$，其中 $[x_1,x_2],[x_3,x_4],…$ 是最大连续涂色段。求得分最大的 $k(k\\le 5\\times 10^3)$ 种选择的得分。 做法 考虑动态规划，$dp_i$ 表示使用了前 $i$ 个格子的前 $k$ 大列表，则 $dp_i$ 可以从 $dp_{-1},dp_0,…,dp_{i-2}$ 处转移 按照上述想法如果直接暴力转移复杂度高达 $O(n^2k)$，需要优化。如果每个 $dp$ 列表都是降序的，新的 $dp_i$ 一定会从所有 $dp_j$ 的前缀转移来，且所有前缀的总长只有 $O(k)$ 级别。换句话说就是对这些列表进行归并，且只归并前 $k$ 个即可。这一过程可以借助优先队列实现，队列中的每个结点记录 $(idx,pos)$ 信息，代表从 $dp_{idx}$ 的第 $pos$ 大数进行转移 CF1957E题意回答 $t(t\\le 10^5)$ 个询问，每次询问给出 $n(n\\le 10^6)$，求 $\\sum_{i=1}^{n}\\sum_{j=1}^{i}\\left(\\frac{i!}{(i-j)!\\cdot j} \\text{ mod } j\\right)$ 做法 观察式子得 $\\frac{i!}{(i-j)!\\cdot j} \\text{ mod } j=\\frac{i\\cdot (i-1)\\cdot(i-2)\\cdot\\ldots\\cdot(i-j+1)}{j}\\text{ mod } j=(j-1)!\\cdot\\lfloor\\frac{i}{j}\\rfloor\\text{ mod }j$ 除了质数和 $4$ 以外，其他数 $j$ 都可以整除 $(j-1)!$，即满足 $(j-1)!\\cdot\\lfloor\\frac{i}{j}\\rfloor\\text{ mod }j=0$ 对于质数，由威尔逊定理，$(j-1)!\\cdot\\lfloor\\frac{i}{j}\\rfloor\\text{ mod }j=(j-1)\\cdot\\lfloor\\frac{i}{j}\\rfloor\\text{ mod }j$ 用一个数组记录 $\\sum_{j=1}^{i}\\left(\\frac{i!}{(i-j)!\\cdot j} \\text{ mod } j\\right)$，枚举质数 $j$ 对数组的差分进行贡献，最终答案为数组的前缀和 威尔逊定理：对于质数 $p$，有 $(p-1)!+1\\equiv 0\\text{ mod }p$. CF1954E题意已知序列 $a(a_i\\le10^5)$ 代表 $n(n\\le 10^5)$ 个怪物的生命值。每次链式攻击可以选择一个存活的怪物造成 $k$ 点伤害并传递：当一个怪物受到伤害时，相邻的存活的怪物也会受到同样的伤害。求对于所有 $k\\in[1,\\max(a)]$，最少要进行多少次链式攻击才能消灭所有怪物。 做法 对于固定的 $k$，显然答案即 $\\sum_i \\max(0,\\lceil \\frac{a_i}{k}\\rceil-\\lceil \\frac{a_{i-1}}{k}\\rceil)$ 考虑数论分块，$\\lceil \\frac{a_i}{k}\\rceil$ 的取值实际上只有 $O(\\log a_i)$ 种。可以枚举 $a$ 的相邻元素计算对答案数组区间的贡献，因为 $\\lceil \\frac{a_i}{k}\\rceil$ 和 $\\lceil \\frac{a_{i-1}}{k}\\rceil$ 的取值一共也只有 $O(\\log{\\max(a_{i-1},a_i)})$ 种。即将 $k$ 的分布区间 $[1,\\max(a)]$ 划分为 $O(\\log{\\max(a_{i-1},a_i)})$ 段分别计算贡献 数论分块通常是向下取整的，即根据 $\\lfloor\\frac{x}{i}\\rfloor$ 的结果分块，但此处需要向上取整的分块，可以利用 $\\lceil \\frac{x}{i}\\rceil=\\lfloor\\frac{x+i-1}{i}\\rfloor=\\lfloor\\frac{x-1}{i}\\rfloor+1$ 的性质转换为 $x-1$ 的向下取整分块","link":"/post/2024.4%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"title":"2024.5 刷题笔记","text":"CF1972D2题意给定 $n,m(1\\le n,m\\le2\\cdot 10^6)$，求满足 $1\\le a\\le n,1\\le b\\le m$ 且 $b\\cdot \\gcd(a,b)$ 是 $a+b$ 的倍数的有序对 $(a,b)$ 的个数。 做法 记 $g=\\gcd(a,b)$。由于 $bg$ 和 $a+b$ 都是 $g$ 的倍数，尝试把 $g$ 约去，得 $b=yg$ 是 $x+y$ 的倍数，其中 $a=xg,b=yg$ 此处还有一个容易忽略的重要性质，即 $\\gcd(x,y)=1$，进而有 $\\gcd(x+y,y)=1$。也就是说，$y$ 中不含 $x+y$ 的质因子，可以从式子中移除，得到 $g$ 是 $x+y$ 的倍数 由于 $x+y&lt;g$ 且 $xg\\le n,yg\\le m$，可以发现无论是 $g$ 较小时还是 $g$ 较大时，$x+y$ 都较小。因此尝试先枚举 $g$ 再枚举 $x+y$ 再枚举 $x$，发现枚举次数较小，刚好能卡过 CF1972E题意给定长度为 $n(n\\le 2\\cdot 10^5)$ 的数组 $b$ 和正整数 $k(k\\le 10^9)$，求一个数组 $a$，使得 $b=f^k(a)\\text{ mod }998244353$，其中 $f(a)$ 表示对 $a$ 建的树状数组，$f^k(a)$ 表示嵌套 $k$ 层操作。 做法 在建立树状数组的过程中，在对应的树上，每个结点都会贡献给它的全体祖先 $k$ 次操作后，每个结点对其父结点的贡献次数为 $k$，对其 $2$ 阶祖先的贡献次数为 $\\sum_{i=1}^{k}i$，对其 $3$ 阶祖先的贡献次数为 $\\sum_{i=1}^{k}\\sum_{j=1}^{i}i$。据此类推，对其 $b$ 阶祖先的贡献次数为一个长度为 $k$ 的数组求 $b$ 次前缀和后的末元素大小。这个问题相当于一个 $k\\times (b+1)$ 的格路问题模型，结果为 $C(k+(b+1)-2,k-1)=C(k+b-1,b)$ 按照 lowbit 从小到大的顺序使每个位置删去贡献即得 $a$ CF1916E题意给定一棵大小为 $n(n\\le 3\\cdot 10^5)$ 的有根树以及每个结点的颜色 $a(a_i\\in[1,n])$，求一对结点 $(u,v)$ 使得 $diff(u,lca(u,v))\\cdot diff(v,lca(u,v))$ 最大。其中 $diff$ 代表两个结点间路径上的颜色种数，$u,v$ 可以相同。 做法 枚举 lca，当 $x$ 作 lca 时找到 $x$ 所有子结点子树中最优的链，选择其中最优的两条链相乘来更新答案。剩下的关键问题是如何快速求出以某结点为根的最优链 考虑在 DFS 回溯的过程中维护当前结点子树中所有结点到当前结点的链的答案，其实只需要在回溯过程中不断将重复颜色的贡献删去即可。当回溯到结点 $x$ 时，需要加上 $x$ 的贡献，其作用于 $x$ 的子树；同时需要删去 $x$ 下方距其最近的同色结点 ${y}$ 的贡献，这些贡献作用于 $y_i$ 的子树。为了方便对子树信息进行修改，可以使用欧拉序将树映射到序列，再用线段树维护序列上每个结点到当前结点的链答案。 GYM105139K题意给定数轴上的 $n(n\\le 10^6)$ 个一维坐标 $a(0\\le a_i&lt;998244353)$，每次随机选择两个相邻的坐标，将它们用它们的平均值替换，直到只剩一个值。求最终值的数学期望。 做法 分别计算每个数的贡献系数，假设某个数当前左边有 $x$ 个数，右边有 $y$ 个数，其贡献系数记为 $f_{i,j}$。根据是否选中该数以及选中该数的左边还是右边分四类情况讨论，得 $f_{i,j}=\\frac{i-1}{i+j}f_{i-1,j}+\\frac{1}{i+j}\\frac{1}{2}f_{i-1,j}+\\frac{j-1}{i+j}f_{i,j-1}+\\frac{1}{i+j}\\frac{1}{2}f_{i,j-1}=\\frac{1}{i+j}((i-\\frac{1}{2})f_{i-1,j}+(j-\\frac{1}{2})f_{i,j-1})$ 令 $g_{i,j}=(i+j)!f_{i,j}$，则 $g_{i,j}=(i-\\frac{1}{2})g_{i-1,j}+(j-\\frac{1}{2})g_{i,j-1}$ 恰好是一个网格图路径计数问题的答案，可以用组合数计算 最终答案为 $\\sum_{i=0}^{i=n-1}f_{i,n-1-i}$ GYM105158D题意给定 $n(n\\le 2\\times 10^5)$ 个二维点坐标，求所有点对中曼哈顿距离比欧几里得距离 $\\frac{\\lVert P_iP_j\\rVert _1}{\\lVert P_iP_j\\rVert _2}$ 的最大值 做法 分析式子得：所求即为连线角度最接近 $45^\\circ$ 或 $135^\\circ$ 的点对 关键结论：分别按照 $x+y$ 和 $x-y$ 排序，最优点对一定在其中一个排序下是相邻的。证明可以考虑任意三个点连成的三角形，其中最上方和最下方的点的连线一定不会是三角形中最接近水平的。 GYM105143D题意给定长度为 $n(n\\le 5000)$ 的数组 $a$，求 $F_{i,j}(1\\le i\\le n,1\\le j\\le 2n)$，其中 $F_{i,j}$ 表示从位置 $i$ 出发走 $j$ 步的所有路径中经过的所有位置元素和最大的路径对应的元素和。 做法 思考答案的计算方法，有 $F_{i,j}=\\max{g_{i,j},g_{i-1,j-1},g_{i-2,j-2},\\cdots,g_{i+1,j-1},g_{i+2,j-2},\\cdots}$，其中 $g_{i,j}$ 表示从 $i$ 出发往一个方向走 $j$ 步的最大结果 先预处理出 $g$ 的所有元素值，然后分别沿着两条对角线求前缀最大值即可 $O(1)$ 计算出 $F$ 的一个元素值 但是会 MLE，因此还需要在第二维上滚动数组优化一下","link":"/post/2024.5%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"title":"Git 学习笔记","text":"简介Git 是一个分布式的版本控制系统。分布式版本控制系统相较于集中式有以下特点： 可以在本地进行提交、分支，而无需联网 每个开发者都有完整的仓库副本，都可以在中央服务器崩溃时恢复整个项目 Git 和其他版本控制系统的主要区别在于，Git 对文件版本的管理并不是基于差异的，而是直接记录文件快照。 而 Github 是一个代码托管云平台，使用 Git 作为底层版本控制工具，允许用户将他们的 Git 仓库托管在云端作为远程仓库，并提供了一系列工具方便开发者间远程协作。 概念工作区域Git 的四大工作区域分别是： 工作目录（Working Directory）：实际进行代码开发的地方 暂存区（Staging Area）：也称为索引（Index），位于工作目录下 .git/index 中，用于临时存放未提交的改动 本地仓库（Local Repository）：位于工作目录下 .git 中，存放完整的项目历史记录 远程仓库（Remote Repository）：位于远程服务器上，存放完整的项目历史记录 工作区之间的工作流： 文件状态Git 中文件的状态分为未跟踪、已跟踪两种，其中已跟踪又细分为未修改、已修改、已暂存三种： 未跟踪（untracked）：工作目录中新建的文件，还未参与版本控制 未修改（Unmodified）：与本地仓库中一致 已修改（Modified）：与本地仓库中不一致且未暂存修改 已暂存（Staged）：与本地仓库中不一致但已暂存修改 版本和分支Git 中每个结点代表一个版本，所有版本及其衍生关系构成描述整个项目历史版本的 DAG 结点：仓库每一次更新都会生成一个新结点，每个结点都有一个唯一对应的 SHA-1 哈希值 分支：指向任意一个结点的指针，代表一个开发工作流 HEAD：指向本地仓库当前所处分支的指针，唯一存在 标签：指向任意一个结点的指针，是对结点的一种静态标记 指令创建本地仓库本地仓库有两种来源，分别是从远程获取或从本地创建 git clone &lt;URL&gt;：将远程仓库复制到本地，并自动创建对远程仓库的引用，命名为“origin” git init：将本地目录作为工作目录创建本地仓库 暂存和提交修改 git add &lt;文件路径&gt;：暂存某一文件的修改 git add .：暂存所有文件的修改 git commit -m &lt;提交信息&gt;：将暂存提交到本地仓库 git commit --amend：往上次提交中补充内容 撤销和回退修改需要注意撤销任何未提交的修改的行为都是危险的，因为不可逆 git reset HEAD &lt;文件路径&gt;：撤销某文件暂存（从已暂存变为已修改） git checkout -- &lt;文件路径&gt;：撤销某文件修改（从已修改变为未修改/已暂存） git reset &lt;提交&gt;：回退到某个结点 --mixed （默认选项）重置 HEAD 和暂存区，但不修改工作目录（仅保留工作目录修改） --soft 仅重置 HEAD，不修改暂存区和工作目录（保留工作目录和暂存区修改） --hard 重置工作目录和暂存区，完全恢复到目标状态（不保留） git revert &lt;提交&gt;：创建一个新的提交以撤销目标提交的修改 &lt;提交&gt; 可以是哈希值/分支名/HEAD/标签名等 查看本地信息 git status：查看工作区和暂存区当前的文件状态 git log：查看提交历史，--oneline 开启简洁模式 git diff：比较工作区和暂存区的所有差异 git diff &lt;文件路径&gt;：比较某文件的差异 管理分支 git branch：查看所有本地分支，-r 查看远程分支，-a 查看所有分支 git branch &lt;分支名&gt;：创建本地分支 git branch -d &lt;分支名&gt;：删除本地分支（可能产生悬空结点） git checkout &lt;分支名&gt;：切换 HEAD 指针位置，同时更新工作目录（但保留修改和暂存），-b 创建并切换 拉取远程仓库更新拉取远程仓库可以使用 pull 或 rebase，其中 pull = fetch + merge，而 rebase 和 pull 的区别在于会将两个分支合并为一条链，使得提交记录更为优雅 git pull &lt;仓库名&gt;：将远程仓库所有分支更新并合并到本地分支，仓库名可省略，使用默认仓库 git pull &lt;仓库名&gt; &lt;分支名&gt;：将远程仓库的某一分支更新合并到本地分支 git pull &lt;仓库名&gt; &lt;分支名1&gt;:&lt;分支名2&gt;：将远程仓库分支1更新合并到本地分支2 git fetch &lt;仓库名&gt; &lt;分支名&gt;：将远程仓库的分支更新到本地仓库 git merge &lt;分支名&gt;：将本地仓库的分支合并到当前分支上 推送本地仓库更新 git push &lt;仓库名&gt;：将本地仓库所有分支更新并合并到远程分支，仓库名可省略，使用默认仓库 git push &lt;仓库名&gt; &lt;分支名&gt;：将本地仓库的某一分支更新合并到远程分支 git push &lt;仓库名&gt; &lt;分支名1&gt;:&lt;分支名2&gt;：将本地仓库分支1更新合并到远程分支2 管理关联的远程仓库本地仓库只有和远程仓库关联后才可以 pull 和 push，本地仓库中会存储所关联的远程仓库的引用 git remote：查看关联的远程仓库，-v 显示 URL git remote add &lt;引用名&gt; &lt;URL&gt;：关联一个远程仓库 git remote show &lt;引用名&gt;：查看远程仓库信息 git remote rename &lt;引用名1&gt; &lt;引用名2&gt;：更改远程仓库引用名 git remote remove &lt;引用名&gt;：移除远程仓库关联 管理标签 git tag：查看所有现有标签 git tag &lt;标签名&gt; &lt;提交&gt;：在某提交上创建标签，提交可省略，默认为 HEAD git tag -a &lt;标签名&gt; -m &lt;标签信息&gt;：创建附注标签 git tag -d &lt;标签名&gt;：删除本地标签 git push origin :refs/tags/&lt;标签名&gt;：（删除本地标签后）删除远程标签 git show &lt;标签名&gt;：查看标签信息 git push origin &lt;标签名&gt;：推送标签 git push origin --tags：推送所有标签 规范提交Git 的提交信息通常按照格式 &lt;提交类型&gt;(&lt;影响范围&gt;): &lt;提交目的&gt; 来填写，其中影响范围可以省略。 提交类型包含以下几种 feat：新功能 fix：修复问题 docs：文档更新 style：代码格式 refactor：代码重构 perf：性能优化 test：添加或更新测试 build：构建系统或外部依赖项的更改 ci：持续集成相关的变动 chore：其他不修改 src 或测试文件的更改 revert：回滚某次提交 分支Git 仓库通常使用“master”或“main”作为主分支，代表稳定的发布版本，其他分支都由主分支产生，最终合并到主分支。 其余的分支包括 develop/...：由主分支产生，用于开发过程 feature/...：由 develop 分支产生，用于开发具体功能特性 release/...：由 develop 分支产生，用于发布版本前进行最后的测试和更新 hotfix/...：由主分支或 release 分支产生，用于修复紧急问题，修复完毕后合并回原分支并删除 .gitignoreGit 仓库根目录下通常有一个文本文件 .gitignore，用于描述不需要跟踪的文件或目录。 .gitignore 使用的语法称为 glob 模式，是一种简化版的正则表达式，通常在 shell 中使用 # 表示注释 * 匹配零个或多个字符 ** 匹配任意多级目录 ? 匹配任意单个字符 [abc] 匹配方括号中任意单个字符 ! 表示不匹配某种字符串 开头的 / 表示相对根目录的路径，若开头没有 / 没有则匹配任意位置 结尾的 / 表示匹配目录而非文件 举个例子： 123456# 忽略 docs 目录下及子目录中除了 Readme/readme 外所有 markdown 文件docs/**/*.md![Rr]eadme.md# 忽略所有一级子目录下的所有单字符名文件或目录/*/?","link":"/post/Git/"},{"title":"Prüfer 序列 简要总结","text":"内容主要总结自 OI Wiki。 简介Prüfer 序列是一种在「包含 $n(n\\ge 2)$ 个有编号结点的无根树」与「整数序列 $a(a_i\\in[1,n],|a|=n-2)$」之间建立双射的方法。 原理由树到序列的映射每次选择树中编号最小的叶结点删除，并将与其连接的结点编号加入序列尾。重复 $n-2$ 次，剩下两个结点。 $O(n)$ 实现：维护编号值域上的指针 $p$，初始指向最小叶结点编号。假设一次删除后新增了叶结点 $x$，若 $x&lt;p$ 则继续删除 $x$，否则让 $p$ 自增到第一个未删除的叶结点并删除。 由序列到树的映射维护每个结点的度。正向遍历序列，每次选择度为 1 的最小编号结点与序列元素对应结点连接，然后减小这两个结点的度。重复 $n-2$ 次，剩下两个度为 1 的结点。 $O(n)$ 实现：同理，维护指针 $p$。假设一次连接后新增了度为 1 的结点 $x$，若 $x&lt;p$ 则继续使用 $x$ 连接，否则让 $p$ 自增到第一个度为 1 的结点并使用其连接。 应用证明凯莱公式 凯莱公式：完全图 $K_n$ 有 $n^{n-2}$ 棵生成树。 完全图 $K_n$ 的生成树集即「包含 $n(n\\ge 2)$ 个有编号结点的无根树」集，而该集合与「整数序列 $a(a_i\\in[1,n],|a|=n-2)$」集有双射关系，因此前者大小等于后者大小，即 $n^{n-2}$。 结论拓展：包含 $n$ 个有编号结点的有根树有 $n^{n-1}$ 种。","link":"/post/Pr%C3%BCfer%E5%BA%8F%E5%88%97/"},{"title":"《STL源码剖析》读书笔记","text":"第一章 - STL概论与版本简介 STL标准模板库提供六大组件：容器（containers）、算法（algorithms）、迭代器（iterators）、仿函数（functors）、配接器（adapters）、配置器（allocators）。它们间的交互关系为：容器通过配置器取得数据储存空间，算法通过迭代器存取容器内容，仿函数可以协助算法完成不同的策略变化，配接器可以修饰或套接仿函数。 第二章 - 空间配置器 空间配置器是隐藏在所有容器背后负责配置空间的组件。 在使用容器时，我们通常不需要自己制定配置器，因为 STL 的每一个容器都已经指定了缺省空间配置器。 我们常用的 new operator 和 delete operator 都包含两个过程： 调用 operator new/operator delete 配置/释放内存空间 调用对象的构造函数/析构函数。 为了精密分工，STL 配置器将这两个过程区分开来：内存的配置与释放由 alloc::allocate() 和 alloc::deallocate() 负责，对象的构造和析构由 ::construct() 和 ::destroy() 负责。 construct() 使用运算子 placement new，在指定位置构造对象。 1234template&lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) { new(p) T1(value); //placement new} destroy() 有两个版本。第一个版本接受一个指针，调用单个对象的析构函数；第二个版本接受两个迭代器，意在批量析构一连串对象。但如果两迭代器指代的范围较大，一次次地调用无意义的构造函数将严重影响效率。所以第二版本使用 traits 技法（第三章）判断元素的数值型别，来决定如何操作。若该型别有 non-trivial destructor，则循环调用所有 destructor，反之则什么也不做。另外，第二版本还针对 char、wchar_t 型迭代器提供了特化版本。 123456789101112131415//第一版本template class&lt;T&gt;inline void destroy(T* pointer) { pointer-&gt;~T(); //调用析构函数}//第二版本template&lt;class ForwardIterator&gt;inline void destroy(ForwardIterator first, ForwardIterator last) { __destroy(first, last, value_type(first)); //获得first对应数值型别}//特化版inline void destroy(char*, char*) {}inline void destroy(wchar_t*, wchar_t*) {} SGI STL 对空间配置与释放的设计理念是： 向 system heap 要求空间 考虑多线程状态（本书不讨论） 考虑内存不足时的应变措施 考虑过多“小型区块”可能造成的“内存碎片”问题 小型区块不仅会带来内存碎片（fragment）问题，还会带来管理内存需要额外负担（overhead）的问题。为了应对小型区块带来的问题，SGI STL 设计了双层级配置器： 第一级配置器直接使用 malloc() 和 free() ，并在系统内存空间无法满足需求时，调用一个客端指定的函数（“内存不足处理例程”）进行处理。 第二级配置器则视情况采取不同策略。如果需要的区块较大，超过 128bytes，就移交第一级配置器处理；如果需要的区块较小，就使用内存池（memory pool）管理，称为次层配置（sub-allocation）。 内存池是指在真正使用内存之前先分配一大块内存来形成一个“池”，留作备用。当有新的内存需求时，就从内存池中分出一部分内存块；若内存块不够，则再继续申请新的内存。这样做能够显著提升内存分配的效率。 次层配置方法：第二级配置器基于内存池维护16个自由链表（free-lists），各自管理大小分别为 8，16，24，…，128bytes 的小额区块。当客端释还小额区块时，就由配置器回收至对应链表中；当有小额区块的需求时，配置器主动将需求量上调至8的倍数，并从对应链表中调取一块区块。但为了管理维护链表，每个节点需要一块指针域。为了避免这样的内存浪费，STL利用了 C++ 作为非强类型语言而特有的常用技巧 union 。让每个节点一物二用：既可以是指向下一节点的指针，又可以是指向实际区块的指针。12345//自由链表节点结构union obj { union obj* free_list_link; //未被分配时作指向下一节点的指针 char client_data[1]; //被分配后作指向实际区块的指针} 当有小额需求时，若自由链表中已经没有区块可用，它将从内存池中获取空间以增加节点。此时若内存池空间足够，则新增 20 个节点；若内存池空间不足但还能提供若干个节点，则新增相应数量节点。若内存池剩余空间已不足供给一个节点，则内存池会利用 malloc() 从堆空间（heap）中配置需求量两倍的内存，再附加一块随配置次数增加的附加内存。若 system heap 空间也不够了，则会先在有更大区块的自由链表中寻找，未找到再调用第一级配置器，利用 out-of-memory 处理机制，看是否有机会释放其他的内存拿来此处使用。最后如果还是失败，则抛出异常。 除 construct() 和 destroy() 外，还有三个内存基本处理函数： uninitialized_copy() 、 uninitialized_fill() 、 uninitialized_fill_n() 。 它们分别对应 STL 算法中的 copy() / fill() / fill_n()（第六章）。 它们可以在实现容器区间构造时被使用，将内存的配置与对象的构造行为分离开来。 它们都具备“commit or rollback”语义，即要么构造出所有必要元素，要么不构造任何东西——若任何一个构造抛出异常，它们必须析构所有已产生的元素。 在实现时，它们先使用 traits 技法（第三章）判断元素的数值型别是否为 POD（Plain Old Data）型别，也就是标量型别（scalar type）或传统的 C 结构体型别。POD 型别必定拥有 trivial constructor/destructor/copy/assignment 函数，因此可以对 POD 型别采用最有效率的初值填写手法，而对 non-POD 型别采取最保险安全的做法。 第三章 - 迭代器概念与 Traits 编程技法 STL 的中心思想在于，将容器与算法分离，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。而迭代器就扮演着这一胶着剂角色。《Dessign Patterns》一书对于 iterator 模式的定义如下： 提供一种方法，使之能够依序巡访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式。 迭代器是一种行为类似指针的对象，其最常见的行为就是内容提领和成员访问。所以设计迭代器时最重要的工作就是重载 operator* 和 operator-&gt;。 在算法中运用迭代器时，很可能会需要知道与迭代器相关的对象类型，即相应型别（associate type） ，例如迭代器所指之物的类型 value_type 。但 C++ 不是强类型语言，无法直接地获得一个对象的类型。所以我们需要利用 template 的参数推导机制以及内嵌类型声明的技巧，“萃取”出相应型别。这就是 traits 编程技法。 123456789101112131415161718192021222324//参数推导机制举例template&lt;class I&gt;inline void func(I iter) { func_impl(iter, *iter); //将func的工作移往func_impl}template&lt;class I, class T&gt;void func_impl(I iter, T t) { T tmp; //成功推导出T，即迭代器所指之物的类型 //...此处为func()原本应做的工作}//参数推导机制只能推导参数类型，而不能推导函数返回值类型//然而声明内嵌类型可以解决这个问题//内嵌类型声明举例template&lt;class T&gt;struct MyIter { typedef T value_type; //内嵌类型声明 T* ptr; MyIter(T* p = 0): ptr(p) {} T&amp; operator*() const { return *ptr; }}template&lt;class I&gt;typename I::type_value func(I ite) { return *ite; }//typename I::type_value即为I所指之物类型，可作为返回值类型 然而这两个技巧还无法完美解决问题。首先，STL 以及整个泛型思维都必须接受原生指针作为一种迭代器，而原生指针无法定义内嵌类型。其次，对于指向常数对象的指针 pointer-to-const，我们期望得到的 value_type 是 non-const 型别而不是 const 型别。为了解决这两个问题，我们还需要针对普通原生指针和指向常数的指针为泛化的 traits 方法提供偏特化版本。要想进行偏特化，首先需要将“萃取”过程交给一个 class template 来专门完成。 123456//专用于“萃取”迭代器特性的classtemplate&lt;class I&gt;struct iterator_traits { typedef typename I::value_type value_type;}//如果I定义了自己的value_type，就可以被其“萃取”出来 这样做让过程多了一层间接性，也使得偏特化可以在 iterator_traits 上进行。 1234567891011//针对原生指针的偏特化template&lt;class T&gt;struct iterator_traits&lt;T*&gt; { typedef T value_type;}//针对pointer-to-const的偏特化template&lt;class T&gt;struct iterator_traits&lt;const T*&gt; { typedef T type_value; //T为non-const型别} 迭代器的五大相应型别为：value_type、difference_type、pointer_type、reference_type、iterator_category。为了符合规范，任何迭代器都应提供五个内嵌相应型别，否则可能无法与 STL 其他组件顺利搭配。 iterator_catagory：根据移动特性与施行操作，迭代器被分为五类。 Input Iterator：所指对象不允许改变，只读 Output Iterator：所指对象不允许改变，唯写 Forward Iterator：可进行读写操作和单向迭代 Bidirectional Iterator：可双向移动 Random Access Iterator：涵盖所有指针算术能力 设计适当的相应型别是迭代器的责任，而设计适当的迭代器则是容器的责任。因为只有容器本身才知道应该设计出怎样的迭代器来遍历自己，并执行迭代器该有的各种行为。这也解释了为什么每一种 STL 容器都有自己的专属迭代器。至于算法，完全可以独立于容器和迭代器之外自行发展。 第四章 - 序列式容器 序列式容器包含 C++ 语言本身提供的 array 和 STL 另外提供的 vector、list、deque、stack、queue、priority_queue。其中 stack 和 queue 由于只是将 deque 改造而成，技术上被归类为一种配接器。 vector： vector 与 array 的唯一差别在于对空间运用的灵活性，所以 vector 实现的关键在于空间扩充。 vector 维护的数据结构是一个连续线性空间，直接使用普通指针作为迭代器，支持随机存取。所以 vector 提供的迭代器类型是 Random Access Iterators 。 vector 在每次空间不足时会重新配置一块大小为原空间两倍的空间并将所有数据转移到新空间内。这样可以保证插入 $n$ 个元素的总时间复杂度为 $O(n)$。需要注意，引起空间重新配置时，原来的所有迭代器都会失效。 vector 在 pop_back() 以及 clear() 等操作时会使用 destroy() 以调用元素对象的析构函数，但不会释放空间。 vector 的其他操作实现原理等同于对线性数组的操作。 list： list 是一个双向链表，其内部维护一个带尾空白节点的双向循环链表，符合 STL 的“前闭后开”要求。 list 的迭代器需要前移、后移，属于 Bidirectional Iterators ，因此不能直接使用普通指针。无论如何进行插入和接合操作，list 的迭代器都不会失效。 list 有一个 list_node_allocator ，专门用以更方便地一次性配置一个节点的空间。 list 的 insert() 操作会将新节点插入目标节点的前方，这符合 STL 的插入操作标准规范。 list的 splice() 操作可以 $O(1)$ 地进行区间接合。 list 不适用 STL 的 sort() ，但有自己的 sort() 成员函数，采用算法为快速排序。 deque： deque 是一个拥有双向开口的连续线性空间。deque 不具有“容量”概念，因为它内部动态地以分段连续空间（称为缓冲区，可以指定大小，默认为 512b）组合而成，随时可以增加并链接一段新空间。 deque 采用一段连续空间作为主控（中控器），称为 map（与 STL 的 map 容器无关）。 map 中每个元素都是指向一段连续线性空间的指针。 map 中的元素从最中央开始向两边扩展，以便同时处理在 deque 两边插入元素的情况。 map 在空间不足时的扩充手段与 vector 类似。 deque 的迭代器属于 Random Access Iterator，但为了在多段连续空间上维护整体连续的假象，不能使用普通指针。deque 的迭代器保存的信息有：当前元素指针、当前缓冲区头指针、当前缓冲区尾指针、当前缓冲区对应中控器中节点的指针。这些信息配合 deque 中的 start 和 finish 迭代器，即可实现 $O(1)$ 随机访存。 deque 自行定义了两个专属空间配置器：data_allocator、map_allocator。 deque 在移除元素时，若缓冲区已空，将会释放缓冲区（除非只剩最后一个缓冲区）。 deque在进行 insert() 和 erase() 操作时，将会根据插入位置前后元素数量判断数据移动策略。 stack： stack 不属于容器，而属于配接器，因为它是通过修改底部容器的接口实现的。 stack 默认以 deque 作为底部结构，封闭其头端开口，只允许存取顶部元素，且不允许遍历，因此也没有迭代器。 除 deque 外，stack 也可以以 list 为底部容器。12//定义以list为底部容器的stackstack&lt;int, list&lt;int&gt;&gt; stk; queue： queue 同样也是一种配接器，性质与 stack 几乎一致，唯一差别在于 queue 双向开口。 heap/priority_queue： heap 不属于 STL 容器组件，但它负责作为 priority_queue 的底层机制。heap 以 vector 为底层容器，性质和相应算法与数据结构中的 heap 一致，此处略。heap 默认为大根堆。 第五章 - 关联式容器 STL 标准中的关联式容器包含 set、multiset、map、multimap，它们都是由红黑树 RB-tree 实现的。 笔记作者补充：C++11 还提供了基于散列表 hashtable 的 unordered_map 和 unordered_set 。 RB-tree： RB-tree也是 STL 中的独立容器，原理与数据结构中的 RB-tree 相同，但并不开放外界使用。 RB-tree 定义了专属空间配置器，可以一次性配置一个节点的空间。 RB-tree 的节点包含实值 value 和键值 key，其中 key 是节点间进行比较的依据。 为了简化边界情况的处理，SGI STL 特别为根节点再设计了一个父节点，称为 header，其左子节点指向最左节点，右子节点指向最右节点。 RB-tree 的迭代器属于 Bidirectional Iterators。为了更大的弹性，RB-tree 的迭代器实现与 RB-tree 的节点实现分为对应的两层。 RB-tree 的插入有 insert_equal()（可重复，插入相同值的最右方）和 insert_unique()（不可重复，若已有则不插入）两种。 set： set 中元素的 value 和 key 是等同的，不像 map 那样可以同时拥有 value 和 key。set 不允许两个元素拥有相同的 key 。我们不可通过 set 的迭代器改变元素的值，因为改变元素值的同时也改变了 key ，会破坏 set 内部的组织和有序性。也因此，set 的迭代器为 constant iterator。 STL 为 set/multiset 提供了一些集合算法：set_intersection() 、 set_union() 、 set_difference() 、 set_symmetric_difference()（第六章）。 map： map 的所有元素都是 pair，pair 中的第一元素为 key，第二元素为 value。map 不允许两个元素拥有相同的 key。我们可以修改 map 元素的 value，但不可以修改其 key。 multiset/multimap： multiset/multimap 与 set/map 几乎相同，唯一区别在于插入时调用的是 insert_equal() ，即允许多个元素拥有相同的 key。 hashtable： SGI STL 的 hashtable 采用开链法处理哈希冲突。它维护一个基于 vector 的表，表中元素称为桶节点（bucket）。每个桶节点并不采用 STL list，而是自行维护一个由 hashtable node 组成的单向链表。 hashtable 以质数作为表格大小，它提前将 28 个逐渐呈现约两倍关系的质数准备好，以备随时取用作为新表格大小。 hashtable 的迭代器属于 Forward Iterator，可沿 bucket vector 及其中链表向下遍历，但无法后退。 有些数据类型元素无法直接输入哈希函数，如字符串等，因此所有元素都需要统一先输入一个函数 bkt_num() ，由它进行转换并调用哈希函数。除整型、C 字符串类型外，其他数据类型都需要用户自定义哈希函数。 第六章 - 算法 STL 算法分为质变算法（mutating algorithms）（需要对目标区间进行改变）和非质变算法（nonmutating algorithms）（不需要对目标区间进行改变）。其中部分质变算法会提供两个版本：in-place（就地改变）版和 copy（生成并返回副本）版。 STL 提供的算法几乎都是施行于一段连续元素空间的算法，接收的前两个参数通常是一对迭代器，用以标示算法的操作区间。STL 通常采用前闭后开区间表示法。每个 STL 算法的声明都表现出它所需要的最低程度的迭代器类型，若传入无效的迭代器，无法在编译时期被发现，且可能导致不可预知的结果。 STL 的算法都经过泛型化，只要传入的迭代器能够进行算法所需的操作，例如前进、后退、提领等，算法就能在任何数据类型和数据结构上完成。 部分算法概览 &lt;numeric&gt; accumulate()：计算所有元素与初始值进行二元运算的结果（默认为求和） adjacent_difference()：构造差分序列 partial_sum()：构造前缀和序列 inner_product()：计算两向量内积 &lt;algorithm&gt; equal()：判断两序列相等 fill() / fill_n()：将序列中所有元素/前 n 个元素改填新值 iter_swap()：将两迭代器所指元素对调 lexicographical_compare()：字典序比较两序列 max() / min()：最大值/最小值 mismatch()：求两序列第一个失配点 swap()：交换两对象内容 copy() / copy_backward()：顺序/倒序复制序列 set_union() / set_intersection() / set_difference() / set_symmetric_difference()：集合并/交/差/对称差 make_heap() / push_heap() / pop_heap() / sort_heap()：堆实现算法 adjacent_find()：找出第一组满足指定条件的相邻元素（默认为相等） count() / count_if()：计算等于指定值/满足指定条件的元素个数 find() / find_if()：找出第一个等于指定值/满足指定条件的元素 for_each()：将仿函数施行于序列上每一元素 generate() / generate_n()将仿函数结果填写在序列所有元素/前 n 个元素上 max_element() / min_element()：找最大值/最小值位置 merge()：合并有序序列到新序列 replace() / replace_copy()：将旧值以新值取代/在新序列上操作 replace_if() / replace_copy_if()：取代满足条件的元素/在新序列上操作 reverse() / reverse_copy()：将序列倒序/在新序列上操作 rotate() / rotate_copy()：交换 $[\\text{begin},\\text{middle})$ 和 $[\\text{middle},\\text{last})$ /在新序列上操作 search() / search_n()：找出子序列/子序列前 n 个元素的首匹配点 swap_ranges()：交换等长区间 transform()：将仿函数施行于序列并由结果产生一个新序列 unique() / unique_copy()：移除重复元素并返回尾指针/在新序列上操作 lower_bound() / upper_bound()：在有序区间上二分查找第一个大于等于/大于指定值的元素 binary_search()：在有序区间上二分查找指定值 next_permutation() / prev_permutation()：将序列变为字典序升序下的下一个/上一个排列，返回是否操作成功 random_shuffle()：将序列随机打乱 partial_sort()：利用堆排序将最小的若干元素置于序列首端并排序，时间复杂度 $O(nlogm)$ sort()：排序。数据量大时采用快速排序，分段后对较小段采用插入排序，递归层次过深时采用堆排序。 equal_range()：在有序区间上二分查找等于指定值的元素区间 inplace_merge()：原地合并两段连续的有序序列 nth_element()：使第 k 大元素在位置 k，且其前方元素都比其小，后方元素都比其大。使用算法类似快速排序的划分区间，但只划分 nth 所在区间，时间复杂度平均 $O(n)$，最坏 $O(n^2)$ merge_sort()：归并排序 第七章 - 仿函数 仿函数也叫函数对象，是一种行为类似函数的对象，其类的定义中必须自定义 operator() 。 仿函数存在的意义：函数指针不能满足 STL 对抽象性的要求，也无法和 STL 其他组件如配接器搭配以产生更灵活的变化。仿函数的主要用途是搭配 STL 算法。 使用 STL 内置的仿函数需要包含 &lt;functional&gt; 类似于迭代器，仿函数必须定义自己的相应型别才能获得可配接性，从而更好地融入 STL 体系。仿函数的相应型别主要用来表现函数参数类型和返回值类型。方便起见，STL 定义了两个类 unary_function、binary_function，分别代表一元仿函数和二元仿函数。 1234567891011121314//一元仿函数template&lt;class Arg, class Result&gt;struct unary_function { typedef Arg argument_type; typedef Result result_type; }//二元仿函数template&lt;class Arg1, class Arg2, class Result&gt;struct binary_function { typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type; } STL 规定，所有仿函数必须继承其中一种类型，以获得其相应型别信息。 算术类仿函数：加法 plus&lt;T&gt; 、减法 minus&lt;T&gt; 、乘法 multiplies&lt;T&gt; 、除法 divides&lt;T&gt; 、模 modulus&lt;T&gt; 、否定 negate&lt;T&gt; 关系运算类仿函数：等于 equal_to&lt;T&gt; 、不等于 not_equal_to&lt;T&gt; 、大于 greater&lt;T&gt; 、大于等于 greater_equal&lt;T&gt; 、小于 less&lt;T&gt; 、小于等于 less_equal&lt;T&gt; 逻辑运算类仿函数：逻辑与 logical_and&lt;T&gt; 、逻辑或 logical_or&lt;T&gt; 、逻辑非 logical_not&lt;T&gt; 其他仿函数：证同（返回自身）identity&lt;T&gt; 、选择（返回 pair 的第一元素或第二元素） select1st&lt;Pair&gt; / select2nd&lt;Pair&gt; 、投射（返回第一参数或第二参数）project1st&lt;Arg1, Arg2&gt; / project2nd&lt;Arg1, Arg2&gt; 第八章 - 配接器 配接器的概念实际上是一种设计模式。《Design Patterns》一书对 adapter 样式的定义如下： 将一个 class 的接口转换为另一个 class 的接口，使原本因接口不兼容而不能合作的 classes 可以一起运作。 STL 提供的配接器中，改变仿函数接口的称为 function adapter，改变容器接口的称为 container adapter，改变迭代器接口的称为 iterator adapter。 容器配接器：queue、stack（第四章）。 迭代器配接器：分为 insert iterators、reverse iterators、iostream iterators，他们的接口在 &lt;iterator&gt; 中。 insert iterators 将一般迭代器的赋值操作转变为插入操作。包括负责尾端插入的 back_insert_iterator、负责首端插入的 front_insert_iterator、可进行任意位置插入的 insert_iterator。当客户端对 insert iterator 进行赋值操作时，insert iterator 会将其转为插入操作；并且，其他迭代器的惯常行为在 insert iterator 中都被关闭。 reverse iterators 将一般迭代器的行进方向逆转，使 operator++ 变成后退， operator-- 变成前进。任何 STL 容器都提供有 rbegin() 和 rend() 这两个操作，它们返回反向遍历容器的迭代器，其中 rbegin() 指向尾元素，而 rend() 指向首元素的前驱元素。 iostream iterators 可绑定到某个数据流（stream）对象身上，分为拥有输入功能的 istream_iterator 和拥有输出功能的 ostream_iterator。所谓绑定一个 istream object，其实就是在 istream iterator 内部维护一个 istream member，客户端对这个迭代器所做的 operator++ 操作会被导引调用迭代器内部所含的 istream member 的输入操作 operator&gt;&gt; 。ostream_iterator 同理。 仿函数配接器：仿函数配接器是所有配接器中数量最庞大的，也是灵活性最强的，可以多次叠加配接。这些配接操作包括：绑定（bind）、否定（negate）、组合（compose）。仿函数的价值在于，通过他们之间的绑定组合，几乎可以无限制地创造出各种表达式，以搭配 STL 算法发挥作用。 一般函数经过 ptr_fun() 处理、成员函数经过 mem_fun() 处理，也都可以获得可配接性。 所有迭代器配接器和仿函数配接器都配有更直观好用的辅助函数，实际运用时通常不直接使用配接器对象而使用辅助函数接口。","link":"/post/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"title":"二分图匹配 简要总结","text":"内容主要总结自 OI Wiki。 概念 二分图：可以划分为两个内部无边点集的图 匹配：没有公共点的边集 极大匹配：无法继续增加边的匹配 最大（权）匹配：边数（边权和）最大的匹配 完美匹配：所有点都有邻接边属于匹配 交错路：由匹配边与非匹配边交错而成的路径 增广路：始于非匹配点且终于非匹配点的交错路 算法最大流算法二分图最大权匹配问题可以建模为最大费用最大流问题：两部分别与源点、汇点间连流量为 1，费用为 0 的边，两部间连流量为 1，费用为边权的边；另外由于最大权匹配不一定是最大匹配，还要在左部和汇点间连流量为 1，费用为 0 的边。此时最大流一定为左部点数，最大费用即最大权。 最大费用最大流问题使用 SSP 或原始对偶等算法解决，此处略。 如果是无权的最大匹配问题，可以直接建模为最大流问题，此处略。 增广路算法匈牙利算法是一种用于解决二分图最大匹配问题的 $O(nm)$ 算法。主要思路是枚举未匹配点找增广路。具体做法为：枚举所有点，进行 DFS 找第一个未匹配点，若找到除自身外的未匹配点，则相当于找到一条增广路，此时更新路上的匹配关系，匹配大小加一。每个点只需要枚举一次，证略。 KM 算法是一种用于解决二分图最大权完美匹配问题的算法。对于普通的二分图最大权匹配问题，可以进行补点使得两部分大小相同，然后利用 KM 算法解决。KM 算法原理略。","link":"/post/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"},{"title":"卡特兰数&amp;斯特林数&amp;贝尔数 学习笔记","text":"卡特兰数 卡特兰数由发现者的名字 Catalan 命名，与植物卡特兰 Cattleya 没有关系。 卡特兰数是组合数学中解决计数问题常用的一个数列，其第 $n$ 项记为 $H_n$： 初值 $H_{0}=1$ 定义 $H_{n}=\\sum_{i=0}^{n-1} H_{i}H_{n-1-i}$ 递推式 $H_{n}=\\frac{4n-2}{n+1}H_{n-1}$ 通项公式 $H_{n}=C_{2n}^{n}-C_{2n}^{n-1}=\\frac{1}{n+1}C_{2n}^{n}$ 生成函数 $H(x)=\\frac{1-\\sqrt{1-4x}}{2x}$ 括号序列计数问题：长度为 $2n$ 的合法括号序列有多少种？ 分析：合法括号序列包含 $n$ 个左括号和 $n$ 个右括号，且每个前缀中右括号的个数不超过左括号。首先，满足第一个条件的序列有 $C_{2n}^{n}$ 种。考虑其中的非法序列，将所有非法序列的第一个非法前缀中所有括号取反，将与包含 $n-1$ 个左括号和 $n+1$ 个右括号的所有括号序列形成一一对应的双射关系。因此非法序列有 $C_{2n}^{n-1}$ 种。答案为 $C_{2n}^{n}-C_{2n}^{n-1}=H_{n}$。 出栈序列计数问题：$1,2,\\cdots,n$ 按顺序进栈，可能的出栈序列有多少种？ 分析：将出栈序列扩展成进出栈序列，进栈相当于左括号，出栈相当于右括号，问题与括号序列计数完全相同。 三角路径计数问题：从 $(0,0)$ 走向 $(n,n)$，每次只能向上或向右走 $1$ 且不能向上穿过直线 $y=x$，这样的路线有多少种？ 分析：将向右视为左括号，向上视为右括号，问题与括号序列计数完全相同。 二叉树计数问题：包含 $n$ 个点的二叉树有多少种形态？ 分析：从根开始考虑，枚举左子树的大小 $i$，有右子树大小 $n-1-i$，得到与卡特兰数定义相同的递推关系 $H_{n}=\\sum_{i=0}^{n-1} H_{i}H_{n-1-i}$，因此答案为卡特兰数 $H_{n}$。 蛋糕切法计数问题：圆上有 $2n$ 个无编号的点，将这些点成对连接使得没有线段相交的方案数有多少种？ 分析：从第一条线开始连，每一种连法会使得一边还剩 $i$ 对点，另一边还剩 $n-1-i$ 对点，得到与卡特兰数定义相同的递推关系 $H_{n}=\\sum_{i=0}^{n-1} H_{i}H_{n-1-i}$，因此答案为卡特兰数 $H_{n}$。 第二类斯特林数 第二类斯特林数在原著中先于第一类斯特林数被介绍，同时也比第一类斯特林数更加常用。 第二类斯特林数是将 $n$ 个有编号的元素划分为 $m$ 个无编号的非空集合的方案数，记为 $S(n,m)$： 初值 $S(n,0)=[n=0]$ 递推式 $S(n,m)=S(n-1,m-1)+mS(n-1,m)$ 通项公式 $S(n,m)=\\frac{1}{m!}\\sum_{i=0}^m(-1)^{m-i}C_m^ii^n=\\sum_{i=0}^m(-1)^{m-i}\\frac{i^n}{i!(m-i)!}$ 考虑插入一个新元素，此时可以选择加入现有集合中的任意一个，也可以选择作为一个新的集合，由此可得递推式；而通项公式可以利用容斥原理/二项式反演推导。 第二类斯特林数的计算实现： 需要预处理 $n\\times m$ 个 $S(i,j)$ 时，可以根据递推式 $O(nm)$ 计算 需要预处理 $m$ 个 $S(n,i)$ 时，可以通过计算多项式 $\\sum_{i=0}^m \\frac{i^n}{i!}x_i$ 和 $\\sum_{i=0}^{m} \\frac{(-1)^i}{i!}x_i$ 的卷积得到，时间复杂度 $O(m\\log m)$ 需要预处理 $n$ 个 $S(i,m)$ 时，分析问题：将 $i$ 个有编号元素划分为 $1$ 个非空集合的方案数用指数型生成函数表达为 $F(x)=\\sum_{i=1}^n\\frac{x^i}{i!}=e^x-1$，此时 $F^m(x)$ 即为将 $i$ 个有编号元素划分为 $m$ 个有编号非空集合的方案数，再除以 $m!$ 即转化为集合无编号的情况。因此 $S(i,m)$ 的指数型生成函数为 $\\frac{\\left[\\frac{x^i}{i!}\\right]F^m(x)}{m!}$ ，计算多项式的幂即可得到答案，时间复杂度 $O(n\\log n)$ 元素无编号时的组合问题用普通生成函数卷积，元素有编号时的组合问题用指数型生成函数卷积。 贝尔数贝尔数是 $n$ 个有编号元素划分为若干无编号非空子集的方案数，记为 $B_i$： 初值 $B_0=1$ 递推式 $B_n=\\sum_{i=0}^{n-1}C_{n-1}^{i}B_i$ 考虑插入一个新元素，此时可以选择若干个元素和新元素组成一个集合，剩下的元素组成剩下的集合，由此可得递推式。 根据定义容易看出，贝尔数实际上就是第二类斯特林数的前缀和 $B_i=\\sum_{i=1}^n S(n,i)$。 贝尔数的计算实现：由前面第二类斯特林数算法的分析，$i$ 个有编号元素划分为任意多个无编号集合的方案为 $\\sum_{i\\ge 0}\\frac{(e^x-1)^i}{i!}=\\exp(e^x-1)$，即贝尔数的指数型生成函数为 $\\exp(e^x-1)$。因此可以先预处理出多项式 $\\sum_{i=1}^n \\frac{1}{i!}x^i$，再求多项式 exp 得到贝尔数的前 $n$ 项，时间复杂度 $O(n\\log n)$。 第一类斯特林数第一类斯特林数是由 $n$ 个有编号的元素构成 $m$ 个无编号的圆排列（轮换）的方案数，记为 $s(n,m)$： 初值 $s(n,0)=[n=0]$ 递推式 $s(n,m)=s(n-1,m-1)+(n-1)s(n-1,m)$ 考虑插入一个新元素，此时可以将新元素插入任意一个数的后方，也可以作为一个新的圆排列，由此可得递推式。 第一类斯特林数的计算实现： 需要预处理 $n\\times m$ 个 $s(i,j)$ 时，可以根据递推式 $O(nm)$ 计算 需要预处理 $n$ 个 $s(n,i)$ 时，根据递推式有 $s(n,i)$ 的生成函数 $F_n(x)=\\frac{(x+n-1)!}{(x-1)!}=x^{\\overline{n}}$，其中 $x^{\\overline{n}}=x^{\\overline{\\lfloor\\frac{n}{2}}\\rfloor}(x+\\lfloor\\frac{n}{2}\\rfloor)^{\\overline{\\lfloor\\frac{n}{2}}\\rfloor}(x+2\\lfloor\\frac{n}{2}\\rfloor)^{\\overline{n-2\\lfloor\\frac{n}{2}}\\rfloor}$ 可以倍增计算。因为由 $x^{\\overline{k}}$ 计算 $f_k(x)=(x+k)^{\\overline{k}}$ 时只需要一次长度为 $k$ 的多项式卷积（推导略），总时间复杂度 $O(n\\log n)$ 需要预处理 $n$ 个 $s(i,m)$ 时，与第二类斯特林数同理分析得 $s(i,m)$ 的指数型生成函数为 $\\frac{\\left[\\frac{x^i}{i!}\\right]F^m(x)}{m!}$，其中 $F(x)=\\sum_{i=1}^n \\frac{x^i}{i}$。求多项式的幂 $O(n\\log n)$ 即得答案","link":"/post/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0&%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0&%E8%B4%9D%E5%B0%94%E6%95%B0/"},{"title":"数据结构 复习笔记","text":"线性表线性表是一种逻辑结构，表示元素有之间一对一的相邻关系，对应的存储结构有顺序表、链表。 链表链表的种类：单向链表、双向链表、循环链表、静态链表 头结点的作用： 第一个元素结点的操作和其他元素的操作一致，不用特殊处理 无论链表是否为空，头指针都非空 顺序表和链表的对比顺序表的优点： 随机访问 不需要存额外信息，存储密度高 Cache 命中率高（符合局部性原理） 链表的优点： 插入删除简单 可动态分配空间，不存在空间浪费 稀疏矩阵的快速转置稀疏矩阵一般用三元组存储，所有元素先按行后按列排序。快速转置算法先记录转置后每一行即原来每一列的元素个数，然后计算出每列元素在新表中的首位置，最后按顺序扫描旧表元素，存放在新表对应位置。 字符串 KMP 算法next 数组代表失配时模式串指针的转移目标，同时也是模式串每个前缀的最长前后缀长度，可以递推计算。 栈和队列栈和队列也属于线性表，但是支持的操作是线性表的子集。 栈共享栈：利用栈底位置不变性，让两个栈共享一个数组空间 链式栈的特点： 无栈满问题，可动态扩充空间 插入删除都只需要在链头进行 $n$ 个元素顺序进栈的出栈序列种类数：卡特兰数 $\\frac{1}{n+1}C_{2n}^{n}$ 队列队列的种类：循环队列、链式队列、双端队列、优先队列 树二叉树二叉树：度不超过 $2$ 的树 满二叉树：所有非叶结点都有两个子结点，总结点数为 $2^h-1$ 完全二叉树：满二叉树最后一层从右向左缺失部分结点 中序+前序/后序可以唯一确定一棵二叉树，但前序+后序不行。 $n$ 个结点的二叉树种类数：卡特兰数 $\\frac{1}{n+1}C_{2n}^{n}$ 树的表示广义表：线性表的递归拓展 父指针表示法：记录每个结点的父结点 左子女右兄弟表示法：可将森林转为二叉树 堆堆属于完全二叉树，通常用数组存储，方便父子关系的表达。 堆的调整：建堆和插入时从下往上调整，移除时从上往下调整 集合与搜索等价类的链表算法插入 $(i,j)$ 等价关系时，将 $i$ 加入 $j$ 链表，将 $j$ 加入 $i$ 链表；输出时用一个数组记录所有元素是否已输出，然后遍历所有链表，在链表 $x$ 中遍历到元素 $y$ 时递归遍历链表 $y$，即可输出所有与 $x$ 等价的元素，时间复杂度 $O(n+m)$。 AVL 树AVL 是一种二叉搜索树，满足每个结点的左子树和右子树高度差（平衡因子）不超过 $1$，在修改后，若平衡被打破，需要进行平衡性旋转恢复平衡。 插入结点时，向上寻找失衡结点，并逐个进行平衡化旋转；对于每个失衡结点，找到回溯路径上其下方的两个结点，若这三个结点呈直线则进行单旋，若呈折线则进行双旋： 左单旋/右单旋 左右双旋/右左双旋 删除结点时，向上寻找失衡结点，并逐个进行平衡化旋转；对于每个失衡结点，找到其不在回溯路径上的子结点，若两结点的删除前的平衡因子相差 $0$ 或 $1$ 则进行单旋，若两结点删除前的平衡因子相差 $2$ 则进行双旋： 左单旋/右单旋 左右双旋/右左双旋 图十字链表&amp;邻接多重表十字链表是针对有向图的一种存图方式。对于每条边，记录其两端的点，以及起点的下一条入边和终点的下一条出边；对于每个点，记录其第一条入边和第一条出边。 邻接多重表是针对无向图的一种存图方式，对于每条边，记录其两端的点，以及两个点的下一条邻接边；对于每个点，记录其第一条邻接边。 图的连通性重连通分量：点双连通分量 关节点：割点 最小生成树Kruskal 算法：选边，稀疏图 Prim 算法：选点，稠密图 最短路Bellman-Ford 算法：任意边权单源最短路 Dijkstra 算法：非负边权单源最短路 Floyd 算法：多源最短路 活动网络找关键路径：先按拓扑序 DP 出最早开始时间，再按逆拓扑序 DP 出最晚开始时间，二者相等的即关键活动 排序插入排序直接插入排序：暴力枚举插入位置，$O(n^2)$，稳定 折半插入排序：二分搜索插入位置，$O(n^2)$，稳定 链表插入排序：使用链表存储序列，$O(n^2)$，稳定 希尔排序：选择一个 $gap_0&lt;n$，每次在间隔为 $gap_i$ 的元素之间使用直接插入排序，并设置 $gap_{i+1}=\\lceil\\frac{gap_i}{2}\\rceil$，直到 $gap_m=1$，时间复杂度未知，不稳定 交换排序冒泡排序：从右到左两两交换，使得前缀有序，$O(n^2)$，稳定 快速排序：用双指针将元素划分到基准两侧，分治计算，平均 $O(n\\log n)$/最坏 $O(n^2)$，不稳定 选择排序直接选择排序：每次选择最小的交换到左边，$O(n^2)$，不稳定 锦标赛排序：用完全二叉树模拟锦标赛过程，$O(n\\log n)$，稳定 堆排序：原地建堆，$O(n\\log n)$，不稳定 归并排序普通归并排序：$O(n\\log n)$，稳定 链表归并排序：不需要额外空间，$O(n\\log n)$，稳定 基数排序最高位优先：先分组再收集，递归分治，$O(d(n+radix))$，稳定 最低位优先：先分组再收集，但不用分治，$O(d(n+radix))$，稳定 外排序待排序信息大于内存容量，需要将部分信息存储在外存上；采用多路归并思想。","link":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"智能指针 学习笔记","text":"简介智能指针是 C++ 用于解决野指针、悬空指针、内存泄漏等问题的内存管理工具，位于头文件 &lt;memory&gt; 中。 野指针：未初始化的指针，非 nullptr悬空指针：指向已释放空间的指针 其中目前还在使用的 unique_ptr/shared_ptr/weak_ptr 由 C++11 引入。C++14 后又有一些相关函数引入，如 std::make_unique() 等。C++20 开始支持 std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;，可以原子地操作智能指针。 智能指针的特性： 遵循 RAII 的原则，在构造函数中获取资源，在析构函数中释放资源 在初始化时会进行空指针检查，避免产生野指针 使用引用计数管理资源，当计数器归零时自动释放资源，避免内存泄漏或悬空指针 std::unique_ptr 独占式智能指针，即每个资源同时最多只能被一个 unique_ptr 拥有 禁止拷贝，删除了拷贝构造函数和拷贝赋值运算符，防止了多个对象同时拥有一个资源 支持移动语义，可以用移动语义转移资源的所有权，源指针将被置为 nullptr std::shared_ptr 共享式智能指针，基于引用计数管理共享资源，常在多线程编程中使用 包含一个指向内存空间的指针和一个指向资源控制块的指针 shared_ptr 不直接支持数组管理，如果指向数组需要自定义删除器 std::weak_ptr 弱引用智能指针，为辅助 shared_ptr 解决循环引用问题而引入 循环引用：智能指针的指向关系形成一个环，导致程序结束时资源无法释放，造成内存泄漏弱引用：不会计入引用次数的引用，允许在必要时释放内存。通常是子结点对祖先结点的引用。 不具有普通指针的功能，不具有资源的访问权，不影响引用计数，只表明一种临时的所有权 可以由 shared_ptr 构造；在需要行使指针行为时需要先尝试调用 weak_ptr::lock() 创建一个 shared_ptr std::auto_ptrauto_ptr 是早期的独占式智能指针，自 C++98 出现，在 C++17 中已被移除。 auto_ptr 的拷贝语义会转移内存的所有权，使源指针悬空，这一特性不符合人的直觉，且在与 STL 容器配合时会带来风险。同时，auto_ptr 也无法管理动态数组。因此 auto_ptr 后来被弃用并移除。 常见问题shared_ptr 的线程安全问题 shared_ptr 资源控制块的修改（如引用计数器的增减）是原子操作，线程安全 多线程读写同一个 shared_ptr 不是线程安全的，因为指向修改不是原子的，包含几个步骤：内容指针移动、原目标引用计数减一、控制指针移动、新目标引用计数加一 多线程读写共享同一资源的不同 shared_ptr 是线程安全的，因此通常按值传参而非按引用 多线程通过 shared_ptr 读写同一资源不是线程安全的，需要加锁 按值传递/按引用传递 unique_ptr 由于禁止了拷贝，不能按值传递，通常按引用传递，也可以使用移动语义 shared_ptr 向线程传递时通常按值传递，否则容易出现线程安全问题 慎用裸指针构造/获取裸指针 用裸指针构造智能指针或获取智能指针的裸指针后，程序既可以从智能指针访问资源，又可以从裸指针访问资源，存在重复析构资源的风险 同理，不应把 this 指针作为 shared_ptr 返回。作为替代，可以继承 std::enable_shared_from_this 类并返回 std::shared_from_this()","link":"/post/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"title":"概率论与数理统计 复习笔记","text":"1 随机事件与概率概率的加法公式$$P(\\cup_{i=1}^{n}A_i)=\\sum_i^n P(A_i)-\\sum_{1\\le i&lt;j\\le n}P(A_iA_j)+\\sum_{1\\le i&lt;j&lt;k\\le n} P(A_iA_jA_k)-\\cdots+(-1)^nP(A_i\\cdots A_j)$$ 类似容斥原理 伯努利试验与二项概率伯努利试验：只有成功或失败两种结果的随机试验 二项概率：$n$ 重伯努利试验恰好成功 $k$ 次的概率 全概率公式和贝叶斯公式假设 $A_1,A_2,\\cdots,A_n$ 构成样本空间的一个划分，$B$ 是某个事件 全概率公式： $$P(B)=\\sum_{i=1}^nP(A_i)P(B|A_i)$$ 贝叶斯公式：当 $P(B)&gt;0$ 时 $$P(A_i|B)=\\frac{P(A_iB)}{P(B)}=\\frac{P(A_i)P(B|A_i)}{\\sum_{l=1}^{n}P(A_l)P(B|A_l)}$$ 2 离散型随机变量及其分布二项分布 $B(n,p)$$n$ 重伯努利试验成功的次数 $X$ 服从二项分布$$P(X=k)=C_n^kp^k(1-p)^{n-k}$$ $n=1$ 的二项分布称为0-1分布 逆二项分布伯努利试验中，成功 $n$ 次时已进行的试验次数 $X$ 服从逆二项分布 $$P(X=k)=C_{k-1}^{n-1}p^n(1-p)^{k-n},k=n,n+1,\\cdots$$ 即前 $k-1$ 次试验恰好成功 $n-1$ 次，且第 $k$ 次试验成功 超几何分布 $H(N,M,n)$$N$ 个物品中有 $M$ 个目标物品，无放回抽样 $n$ 次抽到的目标物品个数 $X$ 服从超几何分布 $$P(X=k)=\\frac{C_M^kC_{N-M}^{n-k} }{C_N^n}$$ 当 $N\\gg n$ 时，超几何分布近似于二项分布，即可以视作有放回抽样 泊松分布 $P(\\lambda)$泊松定理：记 $\\lambda=np$ $$\\underset{n\\rightarrow\\infty}\\lim C_n^k p^k(1-p)^{n-k}=e^{-\\lambda}\\cdot \\frac{\\lambda^k}{k!}$$ 即当 $n$ 较大时，二项分布近似于泊松分布 $$P(X=k)=e^{-\\lambda}\\cdot \\frac{\\lambda^k}{k!}$$ 而泊松分布的概率计算更容易 需要注意由于 $n\\rightarrow \\infty$，为了避免 $\\lambda\\rightarrow\\infty$，需要 $p\\rightarrow 0$ 几何分布伯努利试验中，成功一次时已进行的试验次数 $X$ 服从几何分布 $$P(X=k)=p(1-p)^{k-1}$$ 几何分布是逆二项分布的一种特殊情况 几何分布的无记忆性： $$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$$ 分布的可加性二项分布可加性（可拓展）：$$X\\sim B(m,p),Y\\sim B(n,p)\\Rightarrow X+Y\\sim B(m+n,p)$$ 泊松分布可加性（可拓展）：$$X\\sim P(\\lambda_1),Y\\sim P(\\lambda_2)\\Rightarrow X+Y\\sim P(\\lambda_1+\\lambda_2)$$ 可加性的前提都是相互独立 二维随机变量边缘概率函数不能唯一确定联合概率函数 分布独立性的定义：联合密度函数等于边缘密度函数的乘积 3 连续性随机变量及其分布分布函数和概率密度函数分布函数 $F(x)$：可以表示概率 概率密度函数 $f(x)$：密度，不能表示概率 $F(x)=\\int_{-\\infty}^{\\infty}f(x)dx$ 均匀分布 $R(a,b)$仅在区间 $[a,b]$ 上等概率分布，密度 $\\frac{1}{b-a}$ 指数分布 $E(\\lambda)$概率密度函数 $f(x)=\\begin{cases}\\lambda e^{-\\lambda x},x&gt;0\\\\ 0,x\\le 0\\end{cases}$ 分布函数 $F(x)=\\begin{cases}1-e^{-\\lambda x},x\\ge 0\\\\ 0,x&lt;0\\end{cases}$ 指数分布也具有无记忆性 正态分布（高斯分布）$N(\\mu,\\sigma^2)$概率密度函数 $f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ 正态分布的线性函数的分布：$$X\\sim N(\\mu,\\sigma^2)\\Rightarrow kX+c\\sim N(k\\mu+c,k^2\\sigma)$$ $$X\\sim N(\\mu,\\sigma^2)\\Rightarrow \\frac{X-\\mu}{\\sigma}\\sim N(0,1)$$ 二维正态分布 $N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ 中 $\\rho$ 代表两变量的相关性，两变量的边缘分布都是一维正态分布 联合密度和边缘密度联合密度（点密度） $\\overset{integrate}\\longrightarrow$ 边缘密度（线密度） $\\overset{integrate}\\longrightarrow$ 事件概率（面概率） 正态分布的可加性若 $X,Y$ 相互独立：$$X\\sim N(\\mu_1,\\sigma_1),Y\\sim N(\\mu_2,\\sigma_2)\\\\ \\Rightarrow X+Y\\sim N(\\mu_1+\\mu_2,\\sigma_1^2+\\sigma_2^2),X-Y\\sim N(\\mu_1-\\mu_2,\\sigma_1^2+\\sigma_2^2)$$ （甚至正态分布相乘也是正态分布） 二维随机变量函数的密度函数由 $f(x,y)$ 求 $X=g(x,y)$ 的密度函数：根据 $g(x,y)$ 表达式画出图，进行积分求 $F_Z(z)$，再求导得 $f_Z(z)$ 卷积公式若 $X,Y$ 相互独立，$Z=X+Y$：$$f_Z(z)=\\int_{-\\infty}^{\\infty}f_X(x)f_Y(z-x)dx$$ 4 随机变量的数字特征期望离散随机变量期望（仅当收敛时有定义）：$$E(X)=\\sum_{i=1}^{\\infty}a_ip_i$$ 连续随机变量期望：$$E(X)=\\int_{-\\infty}^{\\infty}xf(x)dx$$ 期望的性质： $E(kX+c)=kE(X)+c$ $X,Y$ 相互独立时，$E(XY)=E(X)E(Y)$ 方差方差在期望的基础上定义：$$D(X)=E{[X-E(X)]^2}=E(X^2)-[E(X)]^2$$ 常见分布的期望和方差 分布 期望 方差 $X^2$ 期望 $B(n,p)$ $np$ $np(1-p)$ $np(1-p)+(np)^2$ $P(\\lambda)$ $\\lambda$ $\\lambda$ $\\lambda^2+\\lambda$ $R(a,b)$ $\\frac{a+b}{2}$ $\\frac{(b-a)^2}{12}$ $E(\\lambda)$ $\\frac{1}{\\lambda}$ $\\frac{1}{\\lambda^2}$ $\\frac{2}{\\lambda^2}$ $H(N,M,n)$ $\\frac{nM}{N}$ 会算 $N(\\mu,\\sigma^2)$ $\\mu$ $\\sigma^2$ 几何分布 $\\frac{1}{p}$ $\\frac{1-p}{p^2}$ $\\frac{2-p}{p^2}$ 协方差协方差反映两个随机变量总体误差的情况：$$\\text{cov}(X,Y)=E{[X-E(X)][Y-E(Y)]}=E(XY)-E(X)E(Y)$$ 协方差的性质： $\\text{cov}(X,c)=0$ $\\text{cov}(X,Y)=\\text{cov}(Y,X)$ $\\text{cov}(\\sum_i X_i,\\sum_j Y_j)=\\sum_i\\sum_j\\text{cov}(X_i,Y_j)$ 方差是协方差的特例：$$D(X)=\\text{cov}(X,X)$$ 相关系数反映两个随机变量的线性相关性：$$\\rho(X,Y)=\\frac{\\text{cov}(X,Y)}{\\sqrt{D(X)D(Y)} }$$ 相互独立一定不相关，不相关不一定相互独立。 切比雪夫不等式$$P(|X-\\mu|\\ge\\epsilon)\\le \\frac{\\sigma^2}{\\epsilon^2}$$ 用于估算随机变量偏移均值的概率上界 柯西-许瓦兹不等式$$[E(XY)]^2\\le E(X^2)E(Y^2)$$ 用于比较矩的大小 5 随机变量序列的极限大数定律切比雪夫大数定律：对于两两不相关的随机变量序列，如果 $D(X_i)$ 有界，那么 $\\frac{1}{n}\\sum_{i=1}^{n}(X_i-E(X_i))$ 依概率收敛于 $0$ 辛钦大数定律：对于独立同分布的随机变量序列，$\\frac{1}{n}i\\sum_{i=1}^{n}X_i$ 依概率收敛于 $E(X)$ 伯努利大数定律：辛钦大数定律对于0-1分布的特例 中心极限定理列维-林德伯格中心极限定理：对于独立同分布的随机变量序列：$$\\underset{n\\rightarrow\\infty}\\lim P\\left(\\sqrt{n}\\frac{\\overline X-\\mu}{\\sigma}\\le x\\right)=\\Phi(x)$$其中 $\\Phi(x)$ 是 $N(0,1)$ 的分布函数 即可以近似认为：$$\\sum_{i=1}^n X_i\\sim N(n\\mu,n\\sigma^2),\\overline X\\sim N(\\mu,\\frac{\\sigma^2}{n})$$ 德莫弗-拉普拉斯中心极限定理：列维-林德伯格中心极限定理对于0-1分布的特例 根据中心极限定理，二项分布在 $n$ 较大时也可以用正态分布近似，优点是不需要 $p$ 趋于零 7 数理统计的基本概念统计量一个随机变量是样本的函数，则称其为统计量，特点是不包含总体分布中的任何未知参数 样本均值的方差：$D(\\overline X)=\\frac{D(X)}{n}$ 样本方差：$S^2=\\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\overline X)^2$ 样本方差不等于样本的二阶中心矩 解释一：因为样本均值是样本对总体均值的估计，使用样本均值引入了一个自由度的消耗（即一个线性约束 $\\overline X=\\frac{1}{n}\\sum_{i=1}^{n}X_i$） 解释二：样本均值与总体均值存在的偏差被忽视了，因此样本方差是对总体方差的低估 卡方分布 $\\chi^2(n)$$n$ 个相互独立且服从标准正态分布变量的平方和服从卡方分布，其中 $n$ 称为自由度 卡方分布的均值和方差：$Y\\sim \\chi^2(n)\\Rightarrow E(Y)=n,D(Y)=2n$ 卡方分布具有可加性（根据定义显然） 学生分布 $t(n)$若 $X,Y$ 相互独立且 $X\\sim N(0,1),Y\\sim\\chi^2(n)$，则$$\\frac{X}{\\sqrt{\\frac{Y}{n} } }\\sim t(n)$$ 其中 $n$ 称为自由度 性质：当 $x\\rightarrow\\infty$ 时，密度函数趋于标准正态分布的密度函数 解释：$\\sqrt{\\frac{Y}{n}}$ 其实是 $n$ 个变量标准差的观测值，趋于 1 F 分布 $F(m,n)$若 $X,Y$ 相互独立且 $X\\sim\\chi^2(m),Y\\sim\\chi^2(n)$，则$$\\frac{\\frac{X}{m} }{\\frac{Y}{n} }\\sim F(m,n)$$ 其中 $(m,n)$ 称为自由度 性质：若 $F\\sim F(m,n)$，则 $\\frac{1}{F}\\sim F(n,m)$ 解释：F 其实是变量方差的观测值的比值 抽样分布统计量的分布都叫抽样分布 对于正态总体 $N(\\mu,\\sigma^2)$ 的样本： $\\overline X\\sim N(\\mu,\\frac{\\sigma^2}{n})$ $\\frac{n-1}{\\sigma^2}S^2\\sim\\chi^2(n-1)$ $\\overline X$ 与 $S^2$ 相互独立（仅限正态分布） 8 参数估计用于估计未知参数的样本的函数称为估计量 估计量的分布都是指随样本的分布 矩估计矩估计的思想是用样本原点矩来替换总体原点矩，从而估计与总体原点矩有关的未知参数 $$\\hat\\sigma^2=S_n^2$$ $$\\hat\\mu=\\overline X$$ 极大似然估计似然函数：$L(\\theta)=\\prod_{i=1}^nf(x_i;\\theta)$，其中 $x_i$ 都视为常数 极大似然估计量：$\\hat\\theta=\\text{argmax }L(\\theta)$ 似然函数通常是多个概率密度函数的乘积，因此通常通过解方程 $\\frac{d}{d\\theta}\\ln L(\\theta)=0$ 来计算极大似然估计 无偏估计无偏估计 $\\hat\\theta$ 满足 $E(\\hat\\theta)=\\theta$ 无偏估计中估计值方差较小的称有效 相合估计量在样本增多时估计值的方差趋近于零 置信区间找一个包含目标参数且随样本服从某一确定分布的变量，从而根据分位数转化得到目标参数的范围 置信区间以估计值为中心，$1-\\alpha$ 是在样本观测值下估计量在置信区间内的概率","link":"/post/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"title":"正则表达式 学习笔记","text":"简介正则表达式是一种用于描述和匹配字符串特定模式的工具。它依据一系列规则，通过一个字符串来表达一个特定的匹配模式。 正则表达式可以应用在各种语言或环境中，如 C++/Python/Javascript/Bash，主要出现在文本搜索替换的场景下。 规则正则表达式中包括普通字符和特殊字符（元字符）：普通字符匹配自身；而元字符不匹配自身，用于表达一些特殊规则。元字符包括：. ^ $ * + ? { } [ ] \\ | ( )。 接下来介绍正则表达式中的一些基础规则。 转义\\ 可以转义元字符，使其在表达式中匹配其本身，如 \\[, \\\\。而 \\ 转义普通字符时则表示一些特殊规则。 字符类[] 用来指定一种字符类，表示可以同时匹配多种字符，如 [abc], [a-zA-Z0-9]。 ^ 可以将字符类的限定范围取反，如 [^a-c]。 除 \\ 和 ^ 以外的元字符在字符类中将作为普通字符身份作用。 预定义字符集\\ 还可以用来表示一些预定义字符集： \\w 匹配任意字母/数字或下划线，相当于 [a-zA-Z0-9_] \\d 匹配任意数字字符，相当于 [0-9] \\s 匹配任意空白字符，相当于 [ \\t\\n\\r\\f\\v] \\W, \\D, \\S 表示它们对应的补集，即 [^a-zA-Z0-9_], [^0-9], [^ \\t\\n\\r\\f\\v] . 匹配除换行符以外的所有字符 这些预定义字符集可以被包含在字符类中，如 [\\dabc]。 分组() 可以将匹配目标分组，从而指明或运算或限定符的作用对象。此时，被分组匹配到的内容会被捕获，可以通过反向引用使用，这样的分组称为捕获组。有时为了提高效率需要不捕获内容，可以使用非捕获组 (?:)，如 (?:[a-z])。 形如 (?) 的表达式除非捕获组以外都不真正匹配任何内容，而是起到一些特殊限定作用，例如前瞻后顾。 或表达式| 用来构成或表达式，表示可以同时匹配多种字符串，如 a (cat|dog)。 限定符限定符用于限定内容的出现次数： ? 表示其左边的内容可以出现 0 次或 1 次 * 表示其左边的内容可以出现 0 次或任意多次 + 表示其左边的内容可以出现 1 次或多次 {} 限定其左边内容的出现次数范围，如 abc{6}, ab(c){1,3}（边界可以省略，默认为 0 和无穷） 零宽断言零宽断言元字符可以指定匹配目标的位置： ^ 用于匹配行首的内容，如 ^a $ 用于匹配行尾的内容，如 a$ \\A 用于匹配字符串首，如 \\Aa \\Z 用于匹配字符串尾，如 a\\Z \\d 用于匹配单词（指 \\w 构成的子串）的边界，如 \\ba, a\\b \\B 用于匹配单词的非边界位置 贪婪匹配包含限定符的表达式会匹配尽可能多的字符，称为贪婪匹配。 ? 出现在限定符右边时，可以将正则表达式中的限定符切换为非贪婪匹配，即匹配尽可能少的字符，如 a*?, a??。 反向引用\\ 加上数字字符可以引用捕获组的内容，如 \\2 可以引用第二个捕获组匹配到的实际内容。 引用到的内容将继续用于匹配，例如 (1)\\1 可以匹配子串 “11”。 前瞻和后顾前瞻和后顾用于限定匹配目标的上下文内容，类似于零宽断言。其中前瞻限定匹配目标的后方内容，而后顾则与之反向： (?=) 表示前瞻，如 \\$(?=\\d) 可以匹配金额 “$100” 中的 “$“ (?!) 表示负前瞻（即对条件取反），如 \\$(?!\\D) 相当于 \\$(?=\\d) (?&lt;=) 表示后顾，如 (?&lt;=\\$)\\d 可以匹配金额 “$100” 中的 “100” (?&lt;!) 表示负后顾，与负前瞻同理 使用C++C++11 引入的 &lt;regex&gt; 库提供了一系列利用正则表达式的工具，例如： std::regex 类表示一个字符串正则表达式 std::smatch 类表示一个匹配结果 std::regex_search() 用于匹配一个正则表达式到字符串的任意部分 std::regex_replace() 用于格式化替换正则表达式在目标字符串中出现的位置 PythonPython 的 re 模块包含正则表达式相关工具，例如： re.Pattern 类表示一个模式对象 re.Match 类表示一个匹配对象 re.compile() 用于将正则表达式字符串编译为模式对象 re.search() 用于寻找第一个匹配位置，并返回匹配对象；re.Pattern.search() 类似 re.sub() 用于替换匹配子串；re.Pattern.sub() 类似 re.Match.group() 用于获取匹配的捕获组 附 - 相关网站 正则表达式测试网站：https://regex101.com/ C++ 正则表达式：https://zh.cppreference.com/w/cpp/regex Python 正则表达式指南：https://docs.python.org/zh-cn/3/howto/regex.html","link":"/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"线性代数 复习笔记","text":"1 行列式行列式的计算$n$ 阶行列式公式：$$D=\\sum_p (-1)^t a_{1p_1}a_{2p_2}\\cdots a_{np_n}$$其中 $p$ 是 $n$ 阶全排列，$t$ 是其对应的逆序数 三阶行列式：主对角平行线积的和减去副对角平行线积的和 上/下三角行列式和对角行列式：主对角线元素的积 行列式的性质 行列式中行与列等价（即对行成立的性质对列也成立） 行列式沿主/副对角线翻转后值不变 交换两行，行列式变号（有两行相同的值为0） 某一行元素的公因数可以提出来 某一行元素为两数之和，则行列式关于该行可分解为两个行列式之和 某一行加上另一行后值不变 $\\left|\\begin{matrix}A&amp;0\\\\ C&amp;D\\end{matrix}\\right|=|A||D|$，$\\left|\\begin{matrix}A&amp;B\\\\ C&amp;D\\end{matrix}\\right|\\neq|A||D|-|B||C|$ 行列式按行展开余子式和代数余子式 余子式：$n$ 阶行列式划去第 $i$ 行第 $j$ 列，剩下的 $n-1$ 阶行列式 $M_{ij}$ 代数余子式：$A_{ij}=(-1)^{i+j}M_{ij}$ 按行展开：$D=\\sum_j a_{rj}A_{rj}$ 2 矩阵及其运算矩阵运算性质矩阵乘法不满足交换律，但满足结合律和分配律 穿脱原理：$(AB)^T=B^TA^T,(AB)^{-1}=A^{-1}B^{-1}$ 若 $A$ 是任意矩阵，则 $AA^T$ 和 $A^TA$ 都是对称阵 $A=0 \\Leftrightarrow A^TA=0$ 方阵的行列式$|AB|=|A||B|$ 伴随矩阵 $A^*$ 是行列式 $|A|$ 各元素的代数余子式构成矩阵的转置矩阵，满足: $AA^*=A^*A=|A|E$ $|A^*|=|A|^{n-1}$，$n$ 为阶数 方阵的逆 $A^{-1}=\\frac{A^*}{|A|}$ 矩阵 $A$ 可逆 $\\Leftrightarrow |A|\\neq 0$（称为非奇异矩阵） $|A^{-1}|=|A|^{-1}$ $(A^{-1})^T=(A^T)^{-1}$ 若 $A$ 可逆，有定义 $A^0=E,A^{-k}=(A^{-1})^{k}$ 若 $A=P\\Lambda P^{-1}$，则 $\\varphi(A)=P\\varphi(\\Lambda)P^{-1}$，其中 $\\varphi$ 是多项式 克拉默法则用于求解线性非齐次方程组的结论，略 矩阵分块分块对角矩阵 行列式等于对角元素的行列式的积 逆等于对角元素分别取逆 分块矩阵的转置等于整体转置+各个转置 3 矩阵的初等变换与线性方程组矩阵的初等变换初等行变换内容： 对换两行 使某一行乘上非零系数 使某一行加上另一行乘系数 初等变换前后的矩阵等价（$A\\sim B$） 初等行变换相当于左乘可逆矩阵，列变换相当于右乘可逆矩阵 初等矩阵：$E$ 进行一次变换操作得到的矩阵 可逆矩阵可以看作对 $E$ 进行一系列初等变换，因此求逆可以从 $E$ 开始用相反顺序执行相反变换 矩阵的秩矩阵的 $k$ 阶子式：任取 $k$ 行 $k$ 列得到的交点构成的 $k$ 阶行列式 矩阵的秩：最高阶非零子式的阶数 $A\\sim B\\Rightarrow R(A)=R(B)$ $R(A^T)=R(A)=R(A^TA)$ $\\max{R(A),R(B)}\\le R(A,B)\\le R(A)+R(B)$ $R(AB)\\le \\min{R(A),R(B)}$（相乘秩不增） 伴随矩阵的秩 $R(A)=n\\Leftrightarrow R(A^*)=n$ $R(A)=n-1\\Leftrightarrow R(A^*)=1$ $R(A)&lt;n-1\\Leftrightarrow R(A^*)=0$ 线性方程组的解$n$ 元线性方程组 $Ax=b$： $R(A)&lt;R(A,b) \\Leftrightarrow$ 无解 $R(A)=R(A,b)=n \\Leftrightarrow$ 唯一解 $R(A)=R(A,b)&lt;n \\Leftrightarrow$ 无限多解 方程组 $Ax=0$ 有非零解 $\\Leftrightarrow$ 有无限多解 4 向量组的线性相关性线性组合与线性表示向量组能互相线性表示称为等价 向量组等价代表向量空间相同，而矩阵等价只需要秩相等 线性相关当向量个数大于维数时一定线性相关 零向量可以被任何向量组线性表示，因此不影响秩 向量空间线性齐次方程组解集的最大无关组称为基础解系，其张成的空间即解集称为解空间，空间的维度等于 $n-R(A)$ 线性非齐次方程组的解集不是向量空间 基和坐标的变换：若基的变换公式为 $(a’_1,a’_2,..,a’_n)=(a_1,a_2,…,a_n)P$，则坐标变换公式为 $\\begin{pmatrix}x’_1\\\\ x’_2\\\\ \\vdots\\\\ x’_3\\end{pmatrix}=P^{-1}\\begin{pmatrix}x_1\\\\ x_2\\\\ \\vdots\\\\ x_3\\end{pmatrix}$，其中 $P=A^{-1}B$ 称为过渡矩阵 基在左，坐标在右；且坐标是列向量 5 相似矩阵和二次型向量的正交性向量的内积：$[x,y]=x^Ty$ 向量的长度：$\\lVert x\\rVert _2$ 向量的夹角：$\\cos\\theta=\\frac{[x,y]}{\\lVert x\\rVert\\lVert y\\rVert}$ 正交指向量内积为零 一组两两正交的非零向量线性无关 标准正交基：单位正交向量组，有无数个 向量 $a$ 在标准正交基 $e$ 中的坐标 $\\lambda=ae$（此处是基在右） 施密特正交化：将基向量减去自己在现有正交基上的投影并加入正交基 正交矩阵：$A^{-1}=A^T \\Leftrightarrow$ 列向量组是单位正交向量组 $A$ 是正交阵 $\\Rightarrow |A|=±1,$ $A,B$ 是正交阵 $\\Rightarrow AB$ 也是正交阵 正交矩阵对应的变换不改变向量长度 方阵的特征值和特征向量若数 $\\lambda$ 和非零列向量 $x$ 满足 $Ax=\\lambda x$，则 $\\lambda$ 称为 $A$ 的特征向量，$x$ 称为对应的特征值 由上述定义推得，特征方程 $|A-\\lambda E|=0$ 的解就是特征值 特征值的性质 特征值的和等于矩阵的迹：$\\sum\\lambda=\\sum a_{ii}$ 特征值的积等于矩阵的行列式 $\\prod\\lambda=|A|$ 非零特征值个数等于矩阵的秩 $R(A)$ 若 $\\lambda$ 是 $A$ 的特征值，则 $\\varphi(\\lambda)$ 是 $\\varphi(A)$ 的特征值 若 $A$ 的特征值各不相等，则特征向量线性无关（注意不可反推） 相似方阵 $B=P^{-1}AP$ 称为方阵 $A$ 的相似矩阵 相似矩阵的特征多项式相同，因此特征值都相同；但特征多项式相同的矩阵不一定相似 求矩阵的特征值或幂需要将矩阵对角化，对角化使用的矩阵 $P$ 由特征列向量构成（$P$ 不唯一，且对角化结果也不唯一） 由上，$A$ 可以对角化 $\\Leftrightarrow A$ 有 $n$ 个线性无关的特征向量 合同方阵 $B=C^{-1}AC$ 称为方阵 $A$ 的合同矩阵，其中 $C$ 可逆 合同变换保持秩、对称性、正负惯性指数，但不保持特征值 正交变换既是相似变换又是合同变换 对称矩阵的对角化对称矩阵的特征值都是实数 对称矩阵不同特征值对应的特征向量正交 对称矩阵一定能被正交对角化（可推广至二次型） 重复特征值对应的特征空间可以找到正交特征向量，但也可以取非正交的，因此也可以非正交对角化 二次型和标准型二次型：含 $n$ 个变量的二次齐次函数 标准型：只含平方项的二次型 二次型可以用矩阵表示为 $x^TAx$，其中 $A$ 为系数构成的对称阵，因此： 二次型与对称阵一一对应 对称阵对角化的规律都可以应用于二次型标准化 正定二次型正/负惯性指数：正/负特征值的个数 惯性定理：合同变换不改变惯性指数 对称矩阵的正定、半正定、负定、半负定、不定 正定 $\\Leftrightarrow$ 特征值全为正 $\\Leftrightarrow$ 各阶主子式全为正 负定 $\\Leftrightarrow$ 奇数阶主子式全为负，偶数阶主子式全为正 6 线性空间与线性变换线性空间线性空间的定义 对加法和数乘封闭 加法交换律、加法结合律 加法零元、负元 乘法结合律、分配律 乘法单位元 子空间：非空子集+对加法和数乘封闭 维数相等的线性空间都同构，即所有向量和向量的线性组合都一一对应 线性变换满足 $T(a_1+a_2)=T(a_1)+T(a_2),T(\\lambda a)=\\lambda T(a)$ 的映射 $T:V_n\\rightarrow U_m$ 称为线性变换 向量组 $A$ 线性相关 $\\Rightarrow$ $T(A)$ 线性相关，但线性无关（逆命题）不一定成立 线性变换的核空间：$N_T={\\alpha|\\alpha\\in V,T\\alpha = 0}$（会被映射到零的向量集合） $\\mathbb{R}^n\\rightarrow\\mathbb{R}^n$ 的线性变换可以用矩阵来表示 $T(x)=Ax$，其中 $A=(T(e_1),T(e_2),…,T(e_n))$","link":"/post/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"移动语义 学习笔记","text":"简介移动语义是 C++11 引入的一项特性，允许在不进行深拷贝的情况下将一个对象资源的所有权转移给另一个对象，从而提高程序的效率。 左值和右值C++ 的所有表达式都有两个属性：类型和值类别。 在 C++98 中，表达式的值类别只有左值和右值两种。其中可以取地址的变量属于左值（不一定能赋值，如 const 引用和字符串字面量），不能取地址的临时数值属于右值（如非字符串的字面量，非引用类型的函数返回值等）。 自 C++11 起，所有表达式被分为三种基本值类别： 纯右值：就是 C++98 中的右值 左值：在 C++98 中的左值基础上新增了具名的右值引用 亡值：随移动语义引入，指匿名的右值引用，如返回右值引用的函数表达式。“亡”代表其在完成初始化或赋值任务后就会消亡 除了三种基本类别外，还有两种混合类别： 右值：包含纯右值和亡值，不能作赋值运算符的左操作数 泛左值：包括亡值和左值，可以通过评估确定对象或函数的标识的值 深拷贝和浅拷贝 浅拷贝：由原对象创建一个新对象，但新对象只是一个指向原对象地址的引用 深拷贝：由原对象创建一个新对象，并在内存中开辟一块新区域存放原对象所有内容的复制 浅拷贝容易产生内存管理问题，而深拷贝容易产生效率问题。 左值引用和右值引用 左值引用（C++98）：Type&amp; name = lvalue;，相当于给左值取别名 右值引用（C++11）：Type&amp;&amp; name = rvalue;，相当于给右值取别名 const 左值引用可以引用右值，而右值引用想引用左值需要通过 std::move()非 const 左值引用只能引用非常量的左值，非 const 右值引用只能引用非常量的右值 右值引用可以延长即将被销毁的匿名临时变量的生命周期，并使其具名、可取址、可修改。但右值引用更重要的一个作用是帮助实现移动语义和完美转发。 移动语义和 std::move()移动语义通过移动构造函数和移动赋值运算符实现。 用户类通常会隐式生成默认移动构造函数，但对于复杂的类往往需要自己编写移动构造函数和移动赋值运算符，来确保： 资源通过浅拷贝转移 移动后原对象不再拥有资源 移动构造函数和移动赋值运算符接收的参数都是一个右值引用，为了区别于拷贝语义，只有在传入参数为右值时才会调用。因此使用移动语义需要依靠 std::move()。std::move() 位于头文件 &lt;utility&gt;，作用是将一个左值强制转换为一个右值引用。无论是调用类的移动构造/赋值时还是实现移动构造/赋值时调用成员变量类的移动都可能需要用到 std::move()。个人理解 std::move() 本质上的作用就是触发移动语义。 常见问题具名的右值引用属于左值具名的右值引用本身属于左值。因此使用它进行对象构造的时候不会调用移动构造函数，而是会调用拷贝构造函数 12// 此处 a 是左值，需要再转换成右值引用以调用 data 的移动构造A(A&amp;&amp; a) : data(std::move(a.data)) {} 完美转发和 std::forward()完美转发是一种编程技巧，指在编写泛型函数时通过模板类型推导保留实参的值类别，以针对不同的情况选择拷贝语义或移动语义。 C++11 中，根据引用折叠规则，在发生类型推导 template&lt;class T&gt; 时，T&amp;&amp; 类型既可以引用左值（T被推导为左值引用），也可以引用右值（T被推导为原始类型），称为万能引用。利用这一特性，可以编写一个转发接口函数，根据推断出的值类别进行选择转发： 12345template&lt;class T&gt;void wrapper(T&amp;&amp; arg) { foo(std::forward&lt;T&gt;(arg));} 此处的 std::forward() 位于头文件 &lt;utility&gt;，作用是根据 T 将参数强制转换为左值引用或右值引用。 引用折叠：类型推导时，若 T 为引用类型，T&amp;&amp; 的右值引用会与原引用根据一套规则进行折叠，例如 int&amp; &amp;&amp; 会被折叠为 int&amp;","link":"/post/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"智能指针","slug":"智能指针","link":"/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"移动语义","slug":"移动语义","link":"/tags/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"}],"categories":[{"name":"刷题","slug":"刷题","link":"/categories/%E5%88%B7%E9%A2%98/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}],"pages":[{"title":"关于","text":"关于博客 基于 Hexo 框架和 Icarus 主题构建，模板来源于 Github 项目 所有文章均为个人笔记，若存在问题，欢迎交流讨论 博客旧址：CSDN 关于我 同济大学软件学院在读本科生 人菜瘾大 ACMer（算法竞赛选手） 热爱数学和编程，追求优雅与效率 联系方式 E-mail：xinyu_lin@tongji.edu.cn QQ：850250678","link":"/about/index.html"}]}